diff -uNp -r mutt.b/PATCHES mutt.a/PATCHES
--- mutt.b/PATCHES	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/PATCHES	2015-09-23 10:28:45.000000000 +0200
@@ -0,0 +1 @@
+patch-1.5.16hg.cd.trash_folder.vl.1
diff -uNp -r mutt.b/commands.c mutt.a/commands.c
--- mutt.b/commands.c	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/commands.c	2015-09-23 10:28:45.000000000 +0200
@@ -720,6 +720,7 @@ int _mutt_save_message (HEADER *h, CONTE
     if (option (OPTDELETEUNTAG))
       mutt_set_flag (Context, h, M_TAG, 0);
   }
+  mutt_set_flag (Context, h, M_APPENDED, 1);
   
   return 0;
 }
diff -uNp -r mutt.b/flags.c mutt.a/flags.c
--- mutt.b/flags.c	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/flags.c	2015-09-23 10:28:45.000000000 +0200
@@ -65,7 +65,13 @@ void _mutt_set_flag (CONTEXT *ctx, HEADE
       {
 	h->deleted = 0;
         update = 1;
-	if (upd_ctx) ctx->deleted--;
+        if (upd_ctx)
+        {
+          ctx->deleted--;
+          if (h->appended)
+            ctx->appended--;
+        }
+        h->appended = 0; /* when undeleting, also reset the appended flag */
 #ifdef USE_IMAP
         /* see my comment above */
 	if (ctx->magic == M_IMAP) 
@@ -87,6 +93,17 @@ void _mutt_set_flag (CONTEXT *ctx, HEADE
       }
       break;
 
+    case M_APPENDED:
+      if (bf)
+      {
+       if (!h->appended)
+       {
+         h->appended = 1;
+         if (upd_ctx) ctx->appended++;
+       }
+      }
+      break;
+
     case M_NEW:
 
       if (!mutt_bit_isset(ctx->rights,M_ACL_SEEN))
diff -uNp -r mutt.b/globals.h mutt.a/globals.h
--- mutt.b/globals.h	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/globals.h	2015-09-23 10:29:30.000000000 +0200
@@ -144,6 +144,7 @@ WHERE char *Tochars;
 WHERE char *TSStatusFormat;
 WHERE char *TSIconFormat;
 WHERE short TSSupported;
+WHERE char *TrashPath;
 WHERE char *Username;
 WHERE char *Visual;
 
diff -uNp -r mutt.b/imap/message.c mutt.a/imap/message.c
--- mutt.b/imap/message.c	2015-09-23 10:26:44.000000000 +0200
+++ mutt.a/imap/message.c	2015-09-23 10:28:45.000000000 +0200
@@ -884,6 +884,7 @@ int imap_copy_messages (CONTEXT* ctx, HE
         if (ctx->hdrs[n]->tagged)
         {
           mutt_set_flag (ctx, ctx->hdrs[n], M_DELETE, 1);
+         mutt_set_flag (ctx, ctx->hdrs[n], M_APPENDED, 1);
           if (option (OPTDELETEUNTAG))
             mutt_set_flag (ctx, ctx->hdrs[n], M_TAG, 0);
         }
@@ -891,6 +892,7 @@ int imap_copy_messages (CONTEXT* ctx, HE
     else
     {
       mutt_set_flag (ctx, h, M_DELETE, 1);
+      mutt_set_flag (ctx, h, M_APPENDED, 1);
       if (option (OPTDELETEUNTAG))
         mutt_set_flag (ctx, h, M_TAG, 0);
     }
diff -uNp -r mutt.b/imap/message.c.orig mutt.a/imap/message.c.orig
--- mutt.b/imap/message.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mutt.a/imap/message.c.orig	2015-09-23 10:26:44.000000000 +0200
@@ -0,0 +1,1303 @@
+/*
+ * Copyright (C) 1996-9 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ */
+
+/* message parsing/updating functions */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <errno.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#include "mutt.h"
+#include "imap_private.h"
+#include "mx.h"
+
+#ifdef HAVE_PGP
+#include "pgp.h"
+#endif
+
+#if USE_HCACHE
+#include "hcache.h"
+#endif
+
+#include "bcache.h"
+
+static FILE* msg_cache_get (IMAP_DATA* idata, HEADER* h);
+static FILE* msg_cache_put (IMAP_DATA* idata, HEADER* h);
+static int msg_cache_commit (IMAP_DATA* idata, HEADER* h);
+
+static void flush_buffer(char* buf, size_t* len, CONNECTION* conn);
+static int msg_fetch_header (CONTEXT* ctx, IMAP_HEADER* h, char* buf,
+  FILE* fp);
+static int msg_parse_fetch (IMAP_HEADER* h, char* s);
+static char* msg_parse_flags (IMAP_HEADER* h, char* s);
+
+/* imap_read_headers:
+ * Changed to read many headers instead of just one. It will return the
+ * msgno of the last message read. It will return a value other than
+ * msgend if mail comes in while downloading headers (in theory).
+ */
+int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
+{
+  CONTEXT* ctx;
+  char *hdrreq = NULL;
+  FILE *fp;
+  char tempfile[_POSIX_PATH_MAX];
+  int msgno, idx = msgbegin - 1;
+  IMAP_HEADER h;
+  IMAP_STATUS* status;
+  int rc, mfhrc, oldmsgcount;
+  int fetchlast = 0;
+  int maxuid = 0;
+  static const char * const want_headers = "DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL";
+  progress_t progress;
+  int retval = -1;
+
+#if USE_HCACHE
+  char buf[LONG_STRING];
+  unsigned int *uid_validity = NULL;
+  unsigned int *puidnext = NULL;
+  unsigned int uidnext = 0;
+  int evalhc = 0;
+#endif /* USE_HCACHE */
+
+  ctx = idata->ctx;
+
+  if (mutt_bit_isset (idata->capabilities,IMAP4REV1))
+  {
+    safe_asprintf (&hdrreq, "BODY.PEEK[HEADER.FIELDS (%s%s%s)]",
+                           want_headers, ImapHeaders ? " " : "", NONULL (ImapHeaders));
+  }
+  else if (mutt_bit_isset (idata->capabilities,IMAP4))
+  {
+    safe_asprintf (&hdrreq, "RFC822.HEADER.LINES (%s%s%s)",
+                           want_headers, ImapHeaders ? " " : "", NONULL (ImapHeaders));
+  }
+  else
+  {	/* Unable to fetch headers for lower versions */
+    mutt_error _("Unable to fetch headers from this IMAP server version.");
+    mutt_sleep (2);	/* pause a moment to let the user see the error */
+    goto error_out_0;
+  }
+
+  /* instead of downloading all headers and then parsing them, we parse them
+   * as they come in. */
+  mutt_mktemp (tempfile, sizeof (tempfile));
+  if (!(fp = safe_fopen (tempfile, "w+")))
+  {
+    mutt_error (_("Could not create temporary file %s"), tempfile);
+    mutt_sleep (2);
+    goto error_out_0;
+  }
+  unlink (tempfile);
+
+  /* make sure context has room to hold the mailbox */
+  while ((msgend) >= idata->ctx->hdrmax)
+    mx_alloc_memory (idata->ctx);
+
+  oldmsgcount = ctx->msgcount;
+  idata->reopen &= ~(IMAP_REOPEN_ALLOW|IMAP_NEWMAIL_PENDING);
+  idata->newMailCount = 0;
+
+#if USE_HCACHE
+  idata->hcache = imap_hcache_open (idata, NULL);
+
+  if (idata->hcache && !msgbegin)
+  {
+    uid_validity = mutt_hcache_fetch_raw (idata->hcache, "/UIDVALIDITY", imap_hcache_keylen);
+    puidnext = mutt_hcache_fetch_raw (idata->hcache, "/UIDNEXT", imap_hcache_keylen);
+    if (puidnext)
+    {
+      uidnext = *puidnext;
+      FREE (&puidnext);
+    }
+    if (uid_validity && uidnext && *uid_validity == idata->uid_validity)
+      evalhc = 1;
+    FREE (&uid_validity);
+  }
+  if (evalhc)
+  {
+    mutt_progress_init (&progress, _("Evaluating cache..."),
+			M_PROGRESS_MSG, ReadInc, msgend + 1);
+
+    snprintf (buf, sizeof (buf),
+      "UID FETCH 1:%u (UID FLAGS)", uidnext - 1);
+
+    imap_cmd_start (idata, buf);
+
+    rc = IMAP_CMD_CONTINUE;
+    for (msgno = msgbegin; rc == IMAP_CMD_CONTINUE; msgno++)
+    {
+      mutt_progress_update (&progress, msgno + 1, -1);
+
+      memset (&h, 0, sizeof (h));
+      h.data = safe_calloc (1, sizeof (IMAP_HEADER_DATA));
+      do
+      {
+        mfhrc = 0;
+
+        rc = imap_cmd_step (idata);
+        if (rc != IMAP_CMD_CONTINUE)
+	{
+	  imap_free_header_data (&h.data);
+          break;
+	}
+
+        /* hole in the header cache */
+        if (!evalhc)
+          continue;
+
+        if ((mfhrc = msg_fetch_header (ctx, &h, idata->buf, NULL)) == -1)
+          continue;
+        else if (mfhrc < 0)
+	{
+	  imap_free_header_data (&h.data);
+          break;
+	}
+
+        if (!h.data->uid)
+        {
+          dprint (2, (debugfile, "imap_read_headers: skipping hcache FETCH "
+                      "response for unknown message number %d\n", h.sid));
+          mfhrc = -1;
+          continue;
+        }
+
+        idx++;
+        ctx->hdrs[idx] = imap_hcache_get (idata, h.data->uid);
+        if (ctx->hdrs[idx])
+        {
+  	  ctx->hdrs[idx]->index = idx;
+  	  /* messages which have not been expunged are ACTIVE (borrowed from mh
+  	   * folders) */
+  	  ctx->hdrs[idx]->active = 1;
+          ctx->hdrs[idx]->read = h.data->read;
+          ctx->hdrs[idx]->old = h.data->old;
+          ctx->hdrs[idx]->deleted = h.data->deleted;
+          ctx->hdrs[idx]->flagged = h.data->flagged;
+          ctx->hdrs[idx]->replied = h.data->replied;
+          ctx->hdrs[idx]->changed = h.data->changed;
+          /*  ctx->hdrs[msgno]->received is restored from mutt_hcache_restore */
+          ctx->hdrs[idx]->data = (void *) (h.data);
+
+          ctx->msgcount++;
+          ctx->size += ctx->hdrs[idx]->content->length;
+        }
+	else
+        {
+	  /* bad header in the cache, we'll have to refetch. */
+          dprint (3, (debugfile, "bad cache entry at %d, giving up\n", h.sid - 1));
+          imap_free_header_data(&h.data);
+          evalhc = 0;
+          idx--;
+        }
+      }
+      while (rc != IMAP_CMD_OK && mfhrc == -1);
+      if (rc == IMAP_CMD_OK)
+        break;
+      if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))
+      {
+        imap_free_header_data (&h.data);
+        imap_hcache_close (idata);
+	goto error_out_1;
+      }
+    }
+    /* could also look for first null header in case hcache is holey */
+    msgbegin = ctx->msgcount;
+  }
+#endif /* USE_HCACHE */
+
+  mutt_progress_init (&progress, _("Fetching message headers..."),
+		      M_PROGRESS_MSG, ReadInc, msgend + 1);
+
+  for (msgno = msgbegin; msgno <= msgend ; msgno++)
+  {
+    mutt_progress_update (&progress, msgno + 1, -1);
+
+    /* we may get notification of new mail while fetching headers */
+    if (msgno + 1 > fetchlast)
+    {
+      char *cmd;
+
+      fetchlast = msgend + 1;
+      safe_asprintf (&cmd, "FETCH %d:%d (UID FLAGS INTERNALDATE RFC822.SIZE %s)",
+                     msgno + 1, fetchlast, hdrreq);
+      imap_cmd_start (idata, cmd);
+      FREE (&cmd);
+    }
+
+    rewind (fp);
+    memset (&h, 0, sizeof (h));
+    h.data = safe_calloc (1, sizeof (IMAP_HEADER_DATA));
+
+    /* this DO loop does two things:
+     * 1. handles untagged messages, so we can try again on the same msg
+     * 2. fetches the tagged response at the end of the last message.
+     */
+    do
+    {
+      mfhrc = 0;
+
+      rc = imap_cmd_step (idata);
+      if (rc != IMAP_CMD_CONTINUE)
+	break;
+
+      if ((mfhrc = msg_fetch_header (ctx, &h, idata->buf, fp)) == -1)
+	continue;
+      else if (mfhrc < 0)
+	break;
+
+      if (!ftello (fp))
+      {
+        dprint (2, (debugfile, "msg_fetch_header: ignoring fetch response with no body\n"));
+        mfhrc = -1;
+        msgend--;
+        continue;
+      }
+
+      /* make sure we don't get remnants from older larger message headers */
+      fputs ("\n\n", fp);
+
+      idx++;
+      if (idx > msgend)
+      {
+        dprint (1, (debugfile, "imap_read_headers: skipping FETCH response for "
+                    "unknown message number %d\n", h.sid));
+        mfhrc = -1;
+        idx--;
+        continue;
+      }
+      /* May receive FLAGS updates in a separate untagged response (#2935) */
+      if (idx < ctx->msgcount)
+      {
+	dprint (2, (debugfile, "imap_read_headers: message %d is not new\n",
+		    h.sid));
+        idx--;
+	continue;
+      }
+
+      ctx->hdrs[idx] = mutt_new_header ();
+
+      ctx->hdrs[idx]->index = h.sid - 1;
+      /* messages which have not been expunged are ACTIVE (borrowed from mh
+       * folders) */
+      ctx->hdrs[idx]->active = 1;
+      ctx->hdrs[idx]->read = h.data->read;
+      ctx->hdrs[idx]->old = h.data->old;
+      ctx->hdrs[idx]->deleted = h.data->deleted;
+      ctx->hdrs[idx]->flagged = h.data->flagged;
+      ctx->hdrs[idx]->replied = h.data->replied;
+      ctx->hdrs[idx]->changed = h.data->changed;
+      ctx->hdrs[idx]->received = h.received;
+      ctx->hdrs[idx]->data = (void *) (h.data);
+
+      if (maxuid < h.data->uid)
+        maxuid = h.data->uid;
+
+      rewind (fp);
+      /* NOTE: if Date: header is missing, mutt_read_rfc822_header depends
+       *   on h.received being set */
+      ctx->hdrs[idx]->env = mutt_read_rfc822_header (fp, ctx->hdrs[idx],
+        0, 0);
+      /* content built as a side-effect of mutt_read_rfc822_header */
+      ctx->hdrs[idx]->content->length = h.content_length;
+      ctx->size += h.content_length;
+
+#if USE_HCACHE
+      imap_hcache_put (idata, ctx->hdrs[idx]);
+#endif /* USE_HCACHE */
+
+      ctx->msgcount++;
+    }
+    while ((rc != IMAP_CMD_OK) && ((mfhrc == -1) ||
+      ((msgno + 1) >= fetchlast)));
+
+    if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))
+    {
+      imap_free_header_data (&h.data);
+#if USE_HCACHE
+      imap_hcache_close (idata);
+#endif
+      goto error_out_1;
+    }
+
+    /* in case we get new mail while fetching the headers */
+    if (idata->reopen & IMAP_NEWMAIL_PENDING)
+    {
+      msgend = idata->newMailCount - 1;
+      while ((msgend) >= ctx->hdrmax)
+	mx_alloc_memory (ctx);
+      idata->reopen &= ~IMAP_NEWMAIL_PENDING;
+      idata->newMailCount = 0;
+    }
+  }
+
+  if (maxuid && (status = imap_mboxcache_get (idata, idata->mailbox, 0)))
+  status->uidnext = maxuid + 1;
+
+#if USE_HCACHE
+  mutt_hcache_store_raw (idata->hcache, "/UIDVALIDITY", &idata->uid_validity,
+                         sizeof (idata->uid_validity), imap_hcache_keylen);
+  if (maxuid && idata->uidnext < maxuid + 1)
+  {
+    dprint (2, (debugfile, "Overriding UIDNEXT: %u -> %u\n", idata->uidnext, maxuid + 1));
+    idata->uidnext = maxuid + 1;
+  }
+  if (idata->uidnext > 1)
+    mutt_hcache_store_raw (idata->hcache, "/UIDNEXT", &idata->uidnext,
+			   sizeof (idata->uidnext), imap_hcache_keylen);
+
+  imap_hcache_close (idata);
+#endif /* USE_HCACHE */
+
+  if (ctx->msgcount > oldmsgcount)
+  {
+    mx_alloc_memory(ctx);
+    mx_update_context (ctx, ctx->msgcount - oldmsgcount);
+  }
+
+  idata->reopen |= IMAP_REOPEN_ALLOW;
+
+  retval = msgend;
+
+error_out_1:
+  safe_fclose (&fp);
+
+error_out_0:
+  FREE (&hdrreq);
+
+  return retval;
+}
+
+int imap_fetch_message (MESSAGE *msg, CONTEXT *ctx, int msgno)
+{
+  IMAP_DATA* idata;
+  HEADER* h;
+  ENVELOPE* newenv;
+  char buf[LONG_STRING];
+  char path[_POSIX_PATH_MAX];
+  char *pc;
+  long bytes;
+  progress_t progressbar;
+  int uid;
+  int cacheno;
+  IMAP_CACHE *cache;
+  int read;
+  int rc;
+  /* Sam's weird courier server returns an OK response even when FETCH
+   * fails. Thanks Sam. */
+  short fetched = 0;
+
+  idata = (IMAP_DATA*) ctx->data;
+  h = ctx->hdrs[msgno];
+
+  if ((msg->fp = msg_cache_get (idata, h)))
+  {
+    if (HEADER_DATA(h)->parsed)
+      return 0;
+    else
+      goto parsemsg;
+  }
+
+  /* we still do some caching even if imap_cachedir is unset */
+  /* see if we already have the message in our cache */
+  cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;
+  cache = &idata->cache[cacheno];
+
+  if (cache->path)
+  {
+    /* don't treat cache errors as fatal, just fall back. */
+    if (cache->uid == HEADER_DATA(h)->uid &&
+        (msg->fp = fopen (cache->path, "r")))
+      return 0;
+    else
+    {
+      unlink (cache->path);
+      FREE (&cache->path);
+    }
+  }
+
+  if (!isendwin())
+    mutt_message _("Fetching message...");
+
+  if (!(msg->fp = msg_cache_put (idata, h)))
+  {
+    cache->uid = HEADER_DATA(h)->uid;
+    mutt_mktemp (path, sizeof (path));
+    cache->path = safe_strdup (path);
+    if (!(msg->fp = safe_fopen (path, "w+")))
+    {
+      FREE (&cache->path);
+      return -1;
+    }
+  }
+
+  /* mark this header as currently inactive so the command handler won't
+   * also try to update it. HACK until all this code can be moved into the
+   * command handler */
+  h->active = 0;
+
+  snprintf (buf, sizeof (buf), "UID FETCH %u %s", HEADER_DATA(h)->uid,
+	    (mutt_bit_isset (idata->capabilities, IMAP4REV1) ?
+	     (option (OPTIMAPPEEK) ? "BODY.PEEK[]" : "BODY[]") :
+	     "RFC822"));
+
+  imap_cmd_start (idata, buf);
+  do
+  {
+    if ((rc = imap_cmd_step (idata)) != IMAP_CMD_CONTINUE)
+      break;
+
+    pc = idata->buf;
+    pc = imap_next_word (pc);
+    pc = imap_next_word (pc);
+
+    if (!ascii_strncasecmp ("FETCH", pc, 5))
+    {
+      while (*pc)
+      {
+	pc = imap_next_word (pc);
+	if (pc[0] == '(')
+	  pc++;
+	if (ascii_strncasecmp ("UID", pc, 3) == 0)
+	{
+	  pc = imap_next_word (pc);
+	  uid = atoi (pc);
+	  if (uid != HEADER_DATA(h)->uid)
+	    mutt_error (_("The message index is incorrect. Try reopening the mailbox."));
+	}
+	else if ((ascii_strncasecmp ("RFC822", pc, 6) == 0) ||
+		 (ascii_strncasecmp ("BODY[]", pc, 6) == 0))
+	{
+	  pc = imap_next_word (pc);
+	  if (imap_get_literal_count(pc, &bytes) < 0)
+	  {
+	    imap_error ("imap_fetch_message()", buf);
+	    goto bail;
+	  }
+	  mutt_progress_init (&progressbar, _("Fetching message..."),
+			      M_PROGRESS_SIZE, NetInc, bytes);
+	  if (imap_read_literal (msg->fp, idata, bytes, &progressbar) < 0)
+	    goto bail;
+	  /* pick up trailing line */
+	  if ((rc = imap_cmd_step (idata)) != IMAP_CMD_CONTINUE)
+	    goto bail;
+	  pc = idata->buf;
+
+	  fetched = 1;
+	}
+	/* UW-IMAP will provide a FLAGS update here if the FETCH causes a
+	 * change (eg from \Unseen to \Seen).
+	 * Uncommitted changes in mutt take precedence. If we decide to
+	 * incrementally update flags later, this won't stop us syncing */
+	else if ((ascii_strncasecmp ("FLAGS", pc, 5) == 0) && !h->changed)
+	{
+	  if ((pc = imap_set_flags (idata, h, pc)) == NULL)
+	    goto bail;
+	}
+      }
+    }
+  }
+  while (rc == IMAP_CMD_CONTINUE);
+
+  /* see comment before command start. */
+  h->active = 1;
+
+  fflush (msg->fp);
+  if (ferror (msg->fp))
+  {
+    mutt_perror (cache->path);
+    goto bail;
+  }
+
+  if (rc != IMAP_CMD_OK)
+    goto bail;
+
+  if (!fetched || !imap_code (idata->buf))
+    goto bail;
+
+  msg_cache_commit (idata, h);
+
+  parsemsg:
+  /* Update the header information.  Previously, we only downloaded a
+   * portion of the headers, those required for the main display.
+   */
+  rewind (msg->fp);
+  /* It may be that the Status header indicates a message is read, but the
+   * IMAP server doesn't know the message has been \Seen. So we capture
+   * the server's notion of 'read' and if it differs from the message info
+   * picked up in mutt_read_rfc822_header, we mark the message (and context
+   * changed). Another possibility: ignore Status on IMAP?*/
+  read = h->read;
+  newenv = mutt_read_rfc822_header (msg->fp, h, 0, 0);
+  mutt_merge_envelopes(h->env, &newenv);
+
+  /* see above. We want the new status in h->read, so we unset it manually
+   * and let mutt_set_flag set it correctly, updating context. */
+  if (read != h->read)
+  {
+    h->read = read;
+    mutt_set_flag (ctx, h, M_NEW, read);
+  }
+
+  h->lines = 0;
+  fgets (buf, sizeof (buf), msg->fp);
+  while (!feof (msg->fp))
+  {
+    h->lines++;
+    fgets (buf, sizeof (buf), msg->fp);
+  }
+
+  h->content->length = ftell (msg->fp) - h->content->offset;
+
+  /* This needs to be done in case this is a multipart message */
+#if defined(HAVE_PGP) || defined(HAVE_SMIME)
+  h->security = crypt_query (h->content);
+#endif
+
+  mutt_clear_error();
+  rewind (msg->fp);
+  HEADER_DATA(h)->parsed = 1;
+
+  return 0;
+
+bail:
+  safe_fclose (&msg->fp);
+  imap_cache_del (idata, h);
+  if (cache->path)
+  {
+    unlink (cache->path);
+    FREE (&cache->path);
+  }
+
+  return -1;
+}
+
+int imap_append_message (CONTEXT *ctx, MESSAGE *msg)
+{
+  IMAP_DATA* idata;
+  FILE *fp;
+  char buf[LONG_STRING];
+  char mbox[LONG_STRING];
+  char mailbox[LONG_STRING];
+  char internaldate[IMAP_DATELEN];
+  char imap_flags[SHORT_STRING];
+  size_t len;
+  progress_t progressbar;
+  size_t sent;
+  int c, last;
+  IMAP_MBOX mx;
+  int rc;
+
+  idata = (IMAP_DATA*) ctx->data;
+
+  if (imap_parse_path (ctx->path, &mx))
+    return -1;
+
+  imap_fix_path (idata, mx.mbox, mailbox, sizeof (mailbox));
+  if (!*mailbox)
+    strfcpy (mailbox, "INBOX", sizeof (mailbox));
+
+  if ((fp = fopen (msg->path, "r")) == NULL)
+  {
+    mutt_perror (msg->path);
+    goto fail;
+  }
+
+  /* currently we set the \Seen flag on all messages, but probably we
+   * should scan the message Status header for flag info. Since we're
+   * already rereading the whole file for length it isn't any more
+   * expensive (it'd be nice if we had the file size passed in already
+   * by the code that writes the file, but that's a lot of changes.
+   * Ideally we'd have a HEADER structure with flag info here... */
+  for (last = EOF, len = 0; (c = fgetc(fp)) != EOF; last = c)
+  {
+    if(c == '\n' && last != '\r')
+      len++;
+
+    len++;
+  }
+  rewind (fp);
+
+  mutt_progress_init (&progressbar, _("Uploading message..."),
+		      M_PROGRESS_SIZE, NetInc, len);
+
+  imap_munge_mbox_name (mbox, sizeof (mbox), mailbox);
+  imap_make_date (internaldate, msg->received);
+
+  imap_flags[0] = imap_flags[1] = 0;
+  if (msg->flags.read)
+    safe_strcat (imap_flags, sizeof (imap_flags), " \\Seen");
+  if (msg->flags.replied)
+    safe_strcat (imap_flags, sizeof (imap_flags), " \\Answered");
+  if (msg->flags.flagged)
+    safe_strcat (imap_flags, sizeof (imap_flags), " \\Flagged");
+  if (msg->flags.draft)
+    safe_strcat (imap_flags, sizeof (imap_flags), " \\Draft");
+
+  snprintf (buf, sizeof (buf), "APPEND %s (%s) \"%s\" {%lu}", mbox,
+            imap_flags + 1,
+	    internaldate,
+	    (unsigned long) len);
+
+  imap_cmd_start (idata, buf);
+
+  do
+    rc = imap_cmd_step (idata);
+  while (rc == IMAP_CMD_CONTINUE);
+
+  if (rc != IMAP_CMD_RESPOND)
+  {
+    char *pc;
+
+    dprint (1, (debugfile, "imap_append_message(): command failed: %s\n",
+		idata->buf));
+
+    pc = idata->buf + SEQLEN;
+    SKIPWS (pc);
+    pc = imap_next_word (pc);
+    mutt_error ("%s", pc);
+    mutt_sleep (1);
+    safe_fclose (&fp);
+    goto fail;
+  }
+
+  for (last = EOF, sent = len = 0; (c = fgetc(fp)) != EOF; last = c)
+  {
+    if (c == '\n' && last != '\r')
+      buf[len++] = '\r';
+
+    buf[len++] = c;
+
+    if (len > sizeof(buf) - 3)
+    {
+      sent += len;
+      flush_buffer(buf, &len, idata->conn);
+      mutt_progress_update (&progressbar, sent, -1);
+    }
+  }
+
+  if (len)
+    flush_buffer(buf, &len, idata->conn);
+
+  mutt_socket_write (idata->conn, "\r\n");
+  safe_fclose (&fp);
+
+  do
+    rc = imap_cmd_step (idata);
+  while (rc == IMAP_CMD_CONTINUE);
+
+  if (!imap_code (idata->buf))
+  {
+    char *pc;
+
+    dprint (1, (debugfile, "imap_append_message(): command failed: %s\n",
+		idata->buf));
+    pc = idata->buf + SEQLEN;
+    SKIPWS (pc);
+    pc = imap_next_word (pc);
+    mutt_error ("%s", pc);
+    mutt_sleep (1);
+    goto fail;
+  }
+
+  FREE (&mx.mbox);
+  return 0;
+
+ fail:
+  FREE (&mx.mbox);
+  return -1;
+}
+
+/* imap_copy_messages: use server COPY command to copy messages to another
+ *   folder.
+ *   Return codes:
+ *      -1: error
+ *       0: success
+ *       1: non-fatal error - try fetch/append */
+int imap_copy_messages (CONTEXT* ctx, HEADER* h, char* dest, int delete)
+{
+  IMAP_DATA* idata;
+  BUFFER cmd, sync_cmd;
+  char mbox[LONG_STRING];
+  char mmbox[LONG_STRING];
+  char prompt[LONG_STRING];
+  int rc;
+  int n;
+  IMAP_MBOX mx;
+  int err_continue = M_NO;
+  int triedcreate = 0;
+
+  idata = (IMAP_DATA*) ctx->data;
+
+  if (imap_parse_path (dest, &mx))
+  {
+    dprint (1, (debugfile, "imap_copy_messages: bad destination %s\n", dest));
+    return -1;
+  }
+
+  /* check that the save-to folder is in the same account */
+  if (!mutt_account_match (&(CTX_DATA->conn->account), &(mx.account)))
+  {
+    dprint (3, (debugfile, "imap_copy_messages: %s not same server as %s\n",
+      dest, ctx->path));
+    return 1;
+  }
+
+  if (h && h->attach_del)
+  {
+    dprint (3, (debugfile, "imap_copy_messages: Message contains attachments to be deleted\n"));
+    return 1;
+  }
+
+  imap_fix_path (idata, mx.mbox, mbox, sizeof (mbox));
+  if (!*mbox)
+    strfcpy (mbox, "INBOX", sizeof (mbox));
+  imap_munge_mbox_name (mmbox, sizeof (mmbox), mbox);
+
+  /* loop in case of TRYCREATE */
+  do
+  {
+    mutt_buffer_init (&sync_cmd);
+    mutt_buffer_init (&cmd);
+
+    /* Null HEADER* means copy tagged messages */
+    if (!h)
+    {
+      /* if any messages have attachments to delete, fall through to FETCH
+       * and APPEND. TODO: Copy what we can with COPY, fall through for the
+       * remainder. */
+      for (n = 0; n < ctx->msgcount; n++)
+      {
+        if (ctx->hdrs[n]->tagged && ctx->hdrs[n]->attach_del)
+        {
+          dprint (3, (debugfile, "imap_copy_messages: Message contains attachments to be deleted\n"));
+          return 1;
+        }
+
+        if (ctx->hdrs[n]->tagged && ctx->hdrs[n]->active &&
+            ctx->hdrs[n]->changed)
+        {
+          rc = imap_sync_message (idata, ctx->hdrs[n], &sync_cmd, &err_continue);
+          if (rc < 0)
+          {
+            dprint (1, (debugfile, "imap_copy_messages: could not sync\n"));
+            goto out;
+          }
+        }
+      }
+
+      rc = imap_exec_msgset (idata, "UID COPY", mmbox, M_TAG, 0, 0);
+      if (!rc)
+      {
+        dprint (1, (debugfile, "imap_copy_messages: No messages tagged\n"));
+        rc = -1;
+        goto out;
+      }
+      else if (rc < 0)
+      {
+        dprint (1, (debugfile, "could not queue copy\n"));
+        goto out;
+      }
+      else
+        mutt_message (_("Copying %d messages to %s..."), rc, mbox);
+    }
+    else
+    {
+      mutt_message (_("Copying message %d to %s..."), h->index+1, mbox);
+      mutt_buffer_printf (&cmd, "UID COPY %u %s", HEADER_DATA (h)->uid, mmbox);
+
+      if (h->active && h->changed)
+      {
+        rc = imap_sync_message (idata, h, &sync_cmd, &err_continue);
+        if (rc < 0)
+        {
+          dprint (1, (debugfile, "imap_copy_messages: could not sync\n"));
+          goto out;
+        }
+      }
+      if ((rc = imap_exec (idata, cmd.data, IMAP_CMD_QUEUE)) < 0)
+      {
+        dprint (1, (debugfile, "could not queue copy\n"));
+        goto out;
+      }
+    }
+
+    /* let's get it on */
+    rc = imap_exec (idata, NULL, IMAP_CMD_FAIL_OK);
+    if (rc == -2)
+    {
+      if (triedcreate)
+      {
+        dprint (1, (debugfile, "Already tried to create mailbox %s\n", mbox));
+        break;
+      }
+      /* bail out if command failed for reasons other than nonexistent target */
+      if (ascii_strncasecmp (imap_get_qualifier (idata->buf), "[TRYCREATE]", 11))
+        break;
+      dprint (3, (debugfile, "imap_copy_messages: server suggests TRYCREATE\n"));
+      snprintf (prompt, sizeof (prompt), _("Create %s?"), mbox);
+      if (option (OPTCONFIRMCREATE) && mutt_yesorno (prompt, 1) < 1)
+      {
+        mutt_clear_error ();
+        goto out;
+      }
+      if (imap_create_mailbox (idata, mbox) < 0)
+        break;
+      triedcreate = 1;
+    }
+  }
+  while (rc == -2);
+
+  if (rc != 0)
+  {
+    imap_error ("imap_copy_messages", idata->buf);
+    goto out;
+  }
+
+  /* cleanup */
+  if (delete)
+  {
+    if (!h)
+      for (n = 0; n < ctx->msgcount; n++)
+      {
+        if (ctx->hdrs[n]->tagged)
+        {
+          mutt_set_flag (ctx, ctx->hdrs[n], M_DELETE, 1);
+          if (option (OPTDELETEUNTAG))
+            mutt_set_flag (ctx, ctx->hdrs[n], M_TAG, 0);
+        }
+      }
+    else
+    {
+      mutt_set_flag (ctx, h, M_DELETE, 1);
+      if (option (OPTDELETEUNTAG))
+        mutt_set_flag (ctx, h, M_TAG, 0);
+    }
+  }
+
+  rc = 0;
+
+ out:
+  if (cmd.data)
+    FREE (&cmd.data);
+  if (sync_cmd.data)
+    FREE (&sync_cmd.data);
+  FREE (&mx.mbox);
+
+  return rc < 0 ? -1 : rc;
+}
+
+static body_cache_t *msg_cache_open (IMAP_DATA *idata)
+{
+  char mailbox[_POSIX_PATH_MAX];
+
+  if (idata->bcache)
+    return idata->bcache;
+
+  imap_cachepath (idata, idata->mailbox, mailbox, sizeof (mailbox));
+
+  return mutt_bcache_open (&idata->conn->account, mailbox);
+}
+
+static FILE* msg_cache_get (IMAP_DATA* idata, HEADER* h)
+{
+  char id[_POSIX_PATH_MAX];
+
+  if (!idata || !h)
+    return NULL;
+
+  idata->bcache = msg_cache_open (idata);
+  snprintf (id, sizeof (id), "%u-%u", idata->uid_validity, HEADER_DATA(h)->uid);
+  return mutt_bcache_get (idata->bcache, id);
+}
+
+static FILE* msg_cache_put (IMAP_DATA* idata, HEADER* h)
+{
+  char id[_POSIX_PATH_MAX];
+
+  if (!idata || !h)
+    return NULL;
+
+  idata->bcache = msg_cache_open (idata);
+  snprintf (id, sizeof (id), "%u-%u", idata->uid_validity, HEADER_DATA(h)->uid);
+  return mutt_bcache_put (idata->bcache, id, 1);
+}
+
+static int msg_cache_commit (IMAP_DATA* idata, HEADER* h)
+{
+  char id[_POSIX_PATH_MAX];
+
+  if (!idata || !h)
+    return -1;
+
+  idata->bcache = msg_cache_open (idata);
+  snprintf (id, sizeof (id), "%u-%u", idata->uid_validity, HEADER_DATA(h)->uid);
+
+  return mutt_bcache_commit (idata->bcache, id);
+}
+
+int imap_cache_del (IMAP_DATA* idata, HEADER* h)
+{
+  char id[_POSIX_PATH_MAX];
+
+  if (!idata || !h)
+    return -1;
+
+  idata->bcache = msg_cache_open (idata);
+  snprintf (id, sizeof (id), "%u-%u", idata->uid_validity, HEADER_DATA(h)->uid);
+  return mutt_bcache_del (idata->bcache, id);
+}
+
+static int msg_cache_clean_cb (const char* id, body_cache_t* bcache, void* data)
+{
+  unsigned int uv, uid, n;
+  IMAP_DATA* idata = (IMAP_DATA*)data;
+
+  if (sscanf (id, "%u-%u", &uv, &uid) != 2)
+    return 0;
+
+  /* bad UID */
+  if (uv != idata->uid_validity)
+    mutt_bcache_del (bcache, id);
+
+  /* TODO: presort UIDs, walk in order */
+  for (n = 0; n < idata->ctx->msgcount; n++)
+  {
+    if (uid == HEADER_DATA(idata->ctx->hdrs[n])->uid)
+      return 0;
+  }
+  mutt_bcache_del (bcache, id);
+
+  return 0;
+}
+
+int imap_cache_clean (IMAP_DATA* idata)
+{
+  idata->bcache = msg_cache_open (idata);
+  mutt_bcache_list (idata->bcache, msg_cache_clean_cb, idata);
+
+  return 0;
+}
+
+/* imap_add_keywords: concatenate custom IMAP tags to list, if they
+ *   appear in the folder flags list. Why wouldn't they? */
+void imap_add_keywords (char* s, HEADER* h, LIST* mailbox_flags, size_t slen)
+{
+  LIST *keywords;
+
+  if (!mailbox_flags || !HEADER_DATA(h) || !HEADER_DATA(h)->keywords)
+    return;
+
+  keywords = HEADER_DATA(h)->keywords->next;
+
+  while (keywords)
+  {
+    if (imap_has_flag (mailbox_flags, keywords->data))
+    {
+      safe_strcat (s, slen, keywords->data);
+      safe_strcat (s, slen, " ");
+    }
+    keywords = keywords->next;
+  }
+}
+
+/* imap_free_header_data: free IMAP_HEADER structure */
+void imap_free_header_data (IMAP_HEADER_DATA** data)
+{
+  if (*data)
+  {
+    /* this should be safe even if the list wasn't used */
+    mutt_free_list (&((*data)->keywords));
+    FREE (data); /* __FREE_CHECKED__ */
+  }
+}
+
+/* imap_set_flags: fill out the message header according to the flags from
+ *   the server. Expects a flags line of the form "FLAGS (flag flag ...)" */
+char* imap_set_flags (IMAP_DATA* idata, HEADER* h, char* s)
+{
+  CONTEXT* ctx = idata->ctx;
+  IMAP_HEADER newh;
+  IMAP_HEADER_DATA* hd;
+  unsigned char readonly;
+
+  memset (&newh, 0, sizeof (newh));
+  hd = h->data;
+  newh.data = hd;
+
+  dprint (2, (debugfile, "imap_fetch_message: parsing FLAGS\n"));
+  if ((s = msg_parse_flags (&newh, s)) == NULL)
+    return NULL;
+
+  /* YAUH (yet another ugly hack): temporarily set context to
+   * read-write even if it's read-only, so *server* updates of
+   * flags can be processed by mutt_set_flag. ctx->changed must
+   * be restored afterwards */
+  readonly = ctx->readonly;
+  ctx->readonly = 0;
+
+  mutt_set_flag (ctx, h, M_NEW, !(hd->read || hd->old));
+  mutt_set_flag (ctx, h, M_OLD, hd->old);
+  mutt_set_flag (ctx, h, M_READ, hd->read);
+  mutt_set_flag (ctx, h, M_DELETE, hd->deleted);
+  mutt_set_flag (ctx, h, M_FLAG, hd->flagged);
+  mutt_set_flag (ctx, h, M_REPLIED, hd->replied);
+
+  /* this message is now definitively *not* changed (mutt_set_flag
+   * marks things changed as a side-effect) */
+  h->changed = 0;
+  ctx->changed &= ~readonly;
+  ctx->readonly = readonly;
+
+  return s;
+}
+
+
+/* msg_fetch_header: import IMAP FETCH response into an IMAP_HEADER.
+ *   Expects string beginning with * n FETCH.
+ *   Returns:
+ *      0 on success
+ *     -1 if the string is not a fetch response
+ *     -2 if the string is a corrupt fetch response */
+static int msg_fetch_header (CONTEXT* ctx, IMAP_HEADER* h, char* buf, FILE* fp)
+{
+  IMAP_DATA* idata;
+  long bytes;
+  int rc = -1; /* default now is that string isn't FETCH response*/
+
+  idata = (IMAP_DATA*) ctx->data;
+
+  if (buf[0] != '*')
+    return rc;
+
+  /* skip to message number */
+  buf = imap_next_word (buf);
+  h->sid = atoi (buf);
+
+  /* find FETCH tag */
+  buf = imap_next_word (buf);
+  if (ascii_strncasecmp ("FETCH", buf, 5))
+    return rc;
+
+  rc = -2; /* we've got a FETCH response, for better or worse */
+  if (!(buf = strchr (buf, '(')))
+    return rc;
+  buf++;
+
+  /* FIXME: current implementation - call msg_parse_fetch - if it returns -2,
+   *   read header lines and call it again. Silly. */
+  if ((rc = msg_parse_fetch (h, buf)) != -2 || !fp)
+    return rc;
+
+  if (imap_get_literal_count (buf, &bytes) == 0)
+  {
+    imap_read_literal (fp, idata, bytes, NULL);
+
+    /* we may have other fields of the FETCH _after_ the literal
+     * (eg Domino puts FLAGS here). Nothing wrong with that, either.
+     * This all has to go - we should accept literals and nonliterals
+     * interchangeably at any time. */
+    if (imap_cmd_step (idata) != IMAP_CMD_CONTINUE)
+      return rc;
+
+    if (msg_parse_fetch (h, idata->buf) == -1)
+      return rc;
+  }
+
+  rc = 0; /* success */
+
+  /* subtract headers from message size - unfortunately only the subset of
+   * headers we've requested. */
+  h->content_length -= bytes;
+
+  return rc;
+}
+
+/* msg_parse_fetch: handle headers returned from header fetch */
+static int msg_parse_fetch (IMAP_HEADER *h, char *s)
+{
+  char tmp[SHORT_STRING];
+  char *ptmp;
+
+  if (!s)
+    return -1;
+
+  while (*s)
+  {
+    SKIPWS (s);
+
+    if (ascii_strncasecmp ("FLAGS", s, 5) == 0)
+    {
+      if ((s = msg_parse_flags (h, s)) == NULL)
+        return -1;
+    }
+    else if (ascii_strncasecmp ("UID", s, 3) == 0)
+    {
+      s += 3;
+      SKIPWS (s);
+      h->data->uid = (unsigned int) atoi (s);
+
+      s = imap_next_word (s);
+    }
+    else if (ascii_strncasecmp ("INTERNALDATE", s, 12) == 0)
+    {
+      s += 12;
+      SKIPWS (s);
+      if (*s != '\"')
+      {
+        dprint (1, (debugfile, "msg_parse_fetch(): bogus INTERNALDATE entry: %s\n", s));
+        return -1;
+      }
+      s++;
+      ptmp = tmp;
+      while (*s && *s != '\"')
+        *ptmp++ = *s++;
+      if (*s != '\"')
+        return -1;
+      s++; /* skip past the trailing " */
+      *ptmp = 0;
+      h->received = imap_parse_date (tmp);
+    }
+    else if (ascii_strncasecmp ("RFC822.SIZE", s, 11) == 0)
+    {
+      s += 11;
+      SKIPWS (s);
+      ptmp = tmp;
+      while (isdigit ((unsigned char) *s))
+        *ptmp++ = *s++;
+      *ptmp = 0;
+      h->content_length = atoi (tmp);
+    }
+    else if (!ascii_strncasecmp ("BODY", s, 4) ||
+      !ascii_strncasecmp ("RFC822.HEADER", s, 13))
+    {
+      /* handle above, in msg_fetch_header */
+      return -2;
+    }
+    else if (*s == ')')
+      s++; /* end of request */
+    else if (*s)
+    {
+      /* got something i don't understand */
+      imap_error ("msg_parse_fetch", s);
+      return -1;
+    }
+  }
+
+  return 0;
+}
+
+/* msg_parse_flags: read a FLAGS token into an IMAP_HEADER */
+static char* msg_parse_flags (IMAP_HEADER* h, char* s)
+{
+  IMAP_HEADER_DATA* hd = h->data;
+
+  /* sanity-check string */
+  if (ascii_strncasecmp ("FLAGS", s, 5) != 0)
+  {
+    dprint (1, (debugfile, "msg_parse_flags: not a FLAGS response: %s\n",
+      s));
+    return NULL;
+  }
+  s += 5;
+  SKIPWS(s);
+  if (*s != '(')
+  {
+    dprint (1, (debugfile, "msg_parse_flags: bogus FLAGS response: %s\n",
+      s));
+    return NULL;
+  }
+  s++;
+
+  mutt_free_list (&hd->keywords);
+  hd->deleted = hd->flagged = hd->replied = hd->read = hd->old = 0;
+
+  /* start parsing */
+  while (*s && *s != ')')
+  {
+    if (ascii_strncasecmp ("\\deleted", s, 8) == 0)
+    {
+      s += 8;
+      hd->deleted = 1;
+    }
+    else if (ascii_strncasecmp ("\\flagged", s, 8) == 0)
+    {
+      s += 8;
+      hd->flagged = 1;
+    }
+    else if (ascii_strncasecmp ("\\answered", s, 9) == 0)
+    {
+      s += 9;
+      hd->replied = 1;
+    }
+    else if (ascii_strncasecmp ("\\seen", s, 5) == 0)
+    {
+      s += 5;
+      hd->read = 1;
+    }
+    else if (ascii_strncasecmp ("\\recent", s, 7) == 0)
+      s += 7;
+    else if (ascii_strncasecmp ("old", s, 3) == 0)
+    {
+      s += 3;
+      hd->old = 1;
+    }
+    else
+    {
+      /* store custom flags as well */
+      char ctmp;
+      char* flag_word = s;
+
+      if (!hd->keywords)
+        hd->keywords = mutt_new_list ();
+
+      while (*s && !ISSPACE (*s) && *s != ')')
+        s++;
+      ctmp = *s;
+      *s = '\0';
+      mutt_add_list (hd->keywords, flag_word);
+      *s = ctmp;
+    }
+    SKIPWS(s);
+  }
+
+  /* wrap up, or note bad flags response */
+  if (*s == ')')
+    s++;
+  else
+  {
+    dprint (1, (debugfile,
+      "msg_parse_flags: Unterminated FLAGS response: %s\n", s));
+    return NULL;
+  }
+
+  return s;
+}
+
+static void flush_buffer(char *buf, size_t *len, CONNECTION *conn)
+{
+  buf[*len] = '\0';
+  mutt_socket_write_n(conn, buf, *len);
+  *len = 0;
+}
diff -uNp -r mutt.b/init.h mutt.a/init.h
--- mutt.b/init.h	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/init.h	2015-09-23 10:28:45.000000000 +0200
@@ -3341,6 +3341,16 @@ struct option_t MuttVars[] = {
   ** provided that ``$$ts_enabled'' has been set. This string is identical in
   ** formatting to the one used by ``$$status_format''.
   */
+  { "trash",           DT_PATH, R_NONE, UL &TrashPath, 0 },
+  /*
+  ** .pp
+  ** If set, this variable specifies the path of the trash folder where the
+  ** mails marked for deletion will be moved, instead of being irremediably
+  ** purged.
+  ** .pp
+  ** NOTE: When you delete a message in the trash folder, it is really
+  ** deleted, so that you have a way to clean the trash.
+  */
 #ifdef USE_SOCKET
   { "tunnel",            DT_STR, R_NONE, UL &Tunnel, UL 0 },
   /*
diff -uNp -r mutt.b/init.h.orig mutt.a/init.h.orig
--- mutt.b/init.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ mutt.a/init.h.orig	2015-09-23 10:25:53.000000000 +0200
@@ -0,0 +1,3691 @@
+/*
+ * Copyright (C) 1996-2002,2007,2010 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2004 g10 Code GmbH
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifdef _MAKEDOC
+# include "config.h"
+# include "doc/makedoc-defs.h"
+#else
+# include "sort.h"
+#endif
+
+#include "buffy.h"
+
+#ifndef _MAKEDOC
+#define DT_MASK		0x0f
+#define DT_BOOL		1 /* boolean option */
+#define DT_NUM		2 /* a number */
+#define DT_STR		3 /* a string */
+#define DT_PATH		4 /* a pathname */
+#define DT_QUAD		5 /* quad-option (yes/no/ask-yes/ask-no) */
+#define DT_SORT		6 /* sorting methods */
+#define DT_RX		7 /* regular expressions */
+#define DT_MAGIC	8 /* mailbox type */
+#define DT_SYN		9 /* synonym for another variable */
+#define DT_ADDR	       10 /* e-mail address */
+
+#define DTYPE(x) ((x) & DT_MASK)
+
+/* subtypes */
+#define DT_SUBTYPE_MASK	0xf0
+#define DT_SORT_ALIAS	0x10
+#define DT_SORT_BROWSER 0x20
+#define DT_SORT_KEYS	0x40
+#define DT_SORT_AUX	0x80
+
+/* flags to parse_set() */
+#define M_SET_INV	(1<<0)	/* default is to invert all vars */
+#define M_SET_UNSET	(1<<1)	/* default is to unset all vars */
+#define M_SET_RESET	(1<<2)	/* default is to reset all vars to default */
+
+/* forced redraw/resort types */
+#define R_NONE		0
+#define R_INDEX		(1<<0)
+#define R_PAGER		(1<<1)
+#define R_RESORT	(1<<2)	/* resort the mailbox */
+#define R_RESORT_SUB	(1<<3)	/* resort subthreads */
+#define R_RESORT_INIT	(1<<4)  /* resort from scratch */
+#define R_TREE		(1<<5)  /* redraw the thread tree */
+#define R_BOTH		(R_INDEX | R_PAGER)
+#define R_RESORT_BOTH	(R_RESORT | R_RESORT_SUB)
+
+struct option_t
+{
+  char *option;
+  short type;
+  short flags;
+  unsigned long data;
+  unsigned long init; /* initial value */
+};
+
+#define UL (unsigned long)
+
+#endif /* _MAKEDOC */
+
+#ifndef ISPELL
+#define ISPELL "ispell"
+#endif
+
+struct option_t MuttVars[] = {
+  /*++*/
+  { "abort_nosubject",	DT_QUAD, R_NONE, OPT_SUBJECT, M_ASKYES },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, when composing messages and no subject is given
+  ** at the subject prompt, composition will be aborted.  If set to
+  ** \fIno\fP, composing messages with no subject given at the subject
+  ** prompt will never be aborted.
+  */
+  { "abort_unmodified",	DT_QUAD, R_NONE, OPT_ABORT, M_YES },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, composition will automatically abort after
+  ** editing the message body if no changes are made to the file (this
+  ** check only happens after the \fIfirst\fP edit of the file).  When set
+  ** to \fIno\fP, composition will never be aborted.
+  */
+  { "alias_file",	DT_PATH, R_NONE, UL &AliasFile, UL "~/.muttrc" },
+  /*
+  ** .pp
+  ** The default file in which to save aliases created by the
+  ** \fC$<create-alias>\fP function. Entries added to this file are
+  ** encoded in the character set specified by $$config_charset if it
+  ** is \fIset\fP or the current character set otherwise.
+  ** .pp
+  ** \fBNote:\fP Mutt will not automatically source this file; you must
+  ** explicitly use the ``$source'' command for it to be executed in case
+  ** this option points to a dedicated alias file.
+  ** .pp
+  ** The default for this option is the currently used muttrc file, or
+  ** ``~/.muttrc'' if no user muttrc was found.
+  */
+  { "alias_format",	DT_STR,  R_NONE, UL &AliasFmt, UL "%4n %2f %t %-10a   %r" },
+  /*
+  ** .pp
+  ** Specifies the format of the data displayed for the ``$alias'' menu.  The
+  ** following \fCprintf(3)\fP-style sequences are available:
+  ** .dl
+  ** .dt %a .dd alias name
+  ** .dt %f .dd flags - currently, a ``d'' for an alias marked for deletion
+  ** .dt %n .dd index number
+  ** .dt %r .dd address which alias expands to
+  ** .dt %t .dd character which indicates if the alias is tagged for inclusion
+  ** .de
+  */
+  { "allow_8bit",	DT_BOOL, R_NONE, OPTALLOW8BIT, 1 },
+  /*
+  ** .pp
+  ** Controls whether 8-bit data is converted to 7-bit using either Quoted-
+  ** Printable or Base64 encoding when sending mail.
+  */
+  { "allow_ansi",      DT_BOOL, R_NONE, OPTALLOWANSI, 0 },
+  /*
+  ** .pp
+  ** Controls whether ANSI color codes in messages (and color tags in
+  ** rich text messages) are to be interpreted.
+  ** Messages containing these codes are rare, but if this option is \fIset\fP,
+  ** their text will be colored accordingly. Note that this may override
+  ** your color choices, and even present a security problem, since a
+  ** message could include a line like
+  ** .ts
+  ** [-- PGP output follows ...
+  ** .te
+  ** .pp
+  ** and give it the same color as your attachment color (see also
+  ** $$crypt_timestamp).
+  */
+  { "arrow_cursor",	DT_BOOL, R_BOTH, OPTARROWCURSOR, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, an arrow (``->'') will be used to indicate the current entry
+  ** in menus instead of highlighting the whole line.  On slow network or modem
+  ** links this will make response faster because there is less that has to
+  ** be redrawn on the screen when moving to the next or previous entries
+  ** in the menu.
+  */
+  { "ascii_chars",	DT_BOOL, R_BOTH, OPTASCIICHARS, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will use plain ASCII characters when displaying thread
+  ** and attachment trees, instead of the default \fIACS\fP characters.
+  */
+  { "askbcc",		DT_BOOL, R_NONE, OPTASKBCC, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will prompt you for blind-carbon-copy (Bcc) recipients
+  ** before editing an outgoing message.
+  */
+  { "askcc",		DT_BOOL, R_NONE, OPTASKCC, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will prompt you for carbon-copy (Cc) recipients before
+  ** editing the body of an outgoing message.
+  */
+  { "assumed_charset", DT_STR, R_NONE, UL &AssumedCharset, UL 0},
+  /*
+  ** .pp
+  ** This variable is a colon-separated list of character encoding
+  ** schemes for messages without character encoding indication.
+  ** Header field values and message body content without character encoding
+  ** indication would be assumed that they are written in one of this list.
+  ** By default, all the header fields and message body without any charset
+  ** indication are assumed to be in ``us-ascii''.
+  ** .pp
+  ** For example, Japanese users might prefer this:
+  ** .ts
+  ** set assumed_charset="iso-2022-jp:euc-jp:shift_jis:utf-8"
+  ** .te
+  ** .pp
+  ** However, only the first content is valid for the message body.
+  */
+  { "attach_charset",    DT_STR,  R_NONE, UL &AttachCharset, UL 0 },
+  /*
+  ** .pp
+  ** This variable is a colon-separated list of character encoding
+  ** schemes for text file attachments. Mutt uses this setting to guess
+  ** which encoding files being attached are encoded in to convert them to
+  ** a proper character set given in $$send_charset.
+  ** .pp
+  ** If \fIunset\fP, the value of $$charset will be used instead.
+  ** For example, the following configuration would work for Japanese
+  ** text handling:
+  ** .ts
+  ** set attach_charset="iso-2022-jp:euc-jp:shift_jis:utf-8"
+  ** .te
+  ** .pp
+  ** Note: for Japanese users, ``iso-2022-*'' must be put at the head
+  ** of the value as shown above if included.
+  */
+  { "attach_format",	DT_STR,  R_NONE, UL &AttachFormat, UL "%u%D%I %t%4n %T%.40d%> [%.7m/%.10M, %.6e%?C?, %C?, %s] " },
+  /*
+  ** .pp
+  ** This variable describes the format of the ``attachment'' menu.  The
+  ** following \fCprintf(3)\fP-style sequences are understood:
+  ** .dl
+  ** .dt %C  .dd charset
+  ** .dt %c  .dd requires charset conversion (``n'' or ``c'')
+  ** .dt %D  .dd deleted flag
+  ** .dt %d  .dd description
+  ** .dt %e  .dd MIME content-transfer-encoding
+  ** .dt %f  .dd filename
+  ** .dt %I  .dd disposition (``I'' for inline, ``A'' for attachment)
+  ** .dt %m  .dd major MIME type
+  ** .dt %M  .dd MIME subtype
+  ** .dt %n  .dd attachment number
+  ** .dt %Q  .dd ``Q'', if MIME part qualifies for attachment counting
+  ** .dt %s  .dd size
+  ** .dt %t  .dd tagged flag
+  ** .dt %T  .dd graphic tree characters
+  ** .dt %u  .dd unlink (=to delete) flag
+  ** .dt %X  .dd number of qualifying MIME parts in this part and its children
+  **             (please see the ``$attachments'' section for possible speed effects)
+  ** .dt %>X .dd right justify the rest of the string and pad with character ``X''
+  ** .dt %|X .dd pad to the end of the line with character ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  */
+  { "attach_sep",	DT_STR,	 R_NONE, UL &AttachSep, UL "\n" },
+  /*
+  ** .pp
+  ** The separator to add between attachments when operating (saving,
+  ** printing, piping, etc) on a list of tagged attachments.
+  */
+  { "attach_split",	DT_BOOL, R_NONE, OPTATTACHSPLIT, 1 },
+  /*
+  ** .pp
+  ** If this variable is \fIunset\fP, when operating (saving, printing, piping,
+  ** etc) on a list of tagged attachments, Mutt will concatenate the
+  ** attachments and will operate on them as a single attachment. The
+  ** $$attach_sep separator is added after each attachment. When \fIset\fP,
+  ** Mutt will operate on the attachments one by one.
+  */
+  { "attribution",	DT_STR,	 R_NONE, UL &Attribution, UL "On %d, %n wrote:" },
+  /*
+  ** .pp
+  ** This is the string that will precede a message which has been included
+  ** in a reply.  For a full listing of defined \fCprintf(3)\fP-like sequences see
+  ** the section on $$index_format.
+  */
+  { "auto_tag",		DT_BOOL, R_NONE, OPTAUTOTAG, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, functions in the \fIindex\fP menu which affect a message
+  ** will be applied to all tagged messages (if there are any).  When
+  ** unset, you must first use the \fC<tag-prefix>\fP function (bound to ``;''
+  ** by default) to make the next function apply to all tagged messages.
+  */
+  { "autoedit",		DT_BOOL, R_NONE, OPTAUTOEDIT, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP along with $$edit_headers, Mutt will skip the initial
+  ** send-menu (prompting for subject and recipients) and allow you to
+  ** immediately begin editing the body of your
+  ** message.  The send-menu may still be accessed once you have finished
+  ** editing the body of your message.
+  ** .pp
+  ** .pp
+  ** \fBNote:\fP when this option is \fIset\fP, you cannot use send-hooks that depend
+  ** on the recipients when composing a new (non-reply) message, as the initial
+  ** list of recipients is empty.
+  ** .pp
+  ** Also see $$fast_reply.
+  */
+  { "beep",		DT_BOOL, R_NONE, OPTBEEP, 1 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, mutt will beep when an error occurs.
+  */
+  { "beep_new",		DT_BOOL, R_NONE, OPTBEEPNEW, 0 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, mutt will beep whenever it prints a message
+  ** notifying you of new mail.  This is independent of the setting of the
+  ** $$beep variable.
+  */
+  { "bounce",	DT_QUAD, R_NONE, OPT_BOUNCE, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether you will be asked to confirm bouncing messages.
+  ** If set to \fIyes\fP you don't get asked if you want to bounce a
+  ** message. Setting this variable to \fIno\fP is not generally useful,
+  ** and thus not recommended, because you are unable to bounce messages.
+  */
+  { "bounce_delivered", DT_BOOL, R_NONE, OPTBOUNCEDELIVERED, 1 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, mutt will include Delivered-To headers when
+  ** bouncing messages.  Postfix users may wish to \fIunset\fP this variable.
+  */
+  { "braille_friendly", DT_BOOL, R_NONE, OPTBRAILLEFRIENDLY, 0 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, mutt will place the cursor at the beginning
+  ** of the current line in menus, even when the $$arrow_cursor variable
+  ** is \fIunset\fP, making it easier for blind persons using Braille displays to
+  ** follow these menus.  The option is \fIunset\fP by default because many
+  ** visual terminals don't permit making the cursor invisible.
+  */
+#if defined(USE_SSL)
+  { "certificate_file",	DT_PATH, R_NONE, UL &SslCertFile, UL "~/.mutt_certificates" },
+  /*
+  ** .pp
+  ** This variable specifies the file where the certificates you trust
+  ** are saved. When an unknown certificate is encountered, you are asked
+  ** if you accept it or not. If you accept it, the certificate can also
+  ** be saved in this file and further connections are automatically
+  ** accepted.
+  ** .pp
+  ** You can also manually add CA certificates in this file. Any server
+  ** certificate that is signed with one of these CA certificates is
+  ** also automatically accepted.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set certificate_file=~/.mutt/certificates
+  ** .te
+  **
+  */
+#endif
+  { "charset",		DT_STR,	 R_NONE, UL &Charset, UL 0 },
+  /*
+  ** .pp
+  ** Character set your terminal uses to display and enter textual data.
+  ** It is also the fallback for $$send_charset.
+  ** .pp
+  ** Upon startup Mutt tries to derive this value from environment variables
+  ** such as \fC$$$LC_CTYPE\fP or \fC$$$LANG\fP.
+  ** .pp
+  ** \fBNote:\fP It should only be set in case Mutt isn't able to determine the
+  ** character set used correctly.
+  */
+  { "check_mbox_size",	DT_BOOL, R_NONE, OPTCHECKMBOXSIZE, 0 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, mutt will use file size attribute instead of
+  ** access time when checking for new mail in mbox and mmdf folders.
+  ** .pp
+  ** This variable is \fIunset\fP by default and should only be enabled when
+  ** new mail detection for these folder types is unreliable or doesn't work.
+  ** .pp
+  ** Note that enabling this variable should happen before any ``$mailboxes''
+  ** directives occur in configuration files regarding mbox or mmdf folders
+  ** because mutt needs to determine the initial new mail status of such a
+  ** mailbox by performing a fast mailbox scan when it is defined.
+  ** Afterwards the new mail status is tracked by file size changes.
+  */
+  { "check_new",	DT_BOOL, R_NONE, OPTCHECKNEW, 1 },
+  /*
+  ** .pp
+  ** \fBNote:\fP this option only affects \fImaildir\fP and \fIMH\fP style
+  ** mailboxes.
+  ** .pp
+  ** When \fIset\fP, Mutt will check for new mail delivered while the
+  ** mailbox is open.  Especially with MH mailboxes, this operation can
+  ** take quite some time since it involves scanning the directory and
+  ** checking each file to see if it has already been looked at.  If
+  ** this variable is \fIunset\fP, no check for new mail is performed
+  ** while the mailbox is open.
+  */
+  { "collapse_unread",	DT_BOOL, R_NONE, OPTCOLLAPSEUNREAD, 1 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, Mutt will not collapse a thread if it contains any
+  ** unread messages.
+  */
+  { "compose_format",	DT_STR,	 R_BOTH, UL &ComposeFormat, UL "-- Mutt: Compose  [Approx. msg size: %l   Atts: %a]%>-" },
+  /*
+  ** .pp
+  ** Controls the format of the status line displayed in the ``compose''
+  ** menu.  This string is similar to $$status_format, but has its own
+  ** set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %a .dd total number of attachments
+  ** .dt %h .dd local hostname
+  ** .dt %l .dd approximate size (in bytes) of the current message
+  ** .dt %v .dd Mutt version string
+  ** .de
+  ** .pp
+  ** See the text describing the $$status_format option for more
+  ** information on how to set $$compose_format.
+  */
+  { "config_charset",	DT_STR,  R_NONE, UL &ConfigCharset, UL 0 },
+  /*
+  ** .pp
+  ** When defined, Mutt will recode commands in rc files from this
+  ** encoding to the current character set as specified by $$charset
+  ** and aliases written to $$alias_file from the current character set.
+  ** .pp
+  ** Please note that if setting $$charset it must be done before
+  ** setting $$config_charset.
+  ** .pp
+  ** Recoding should be avoided as it may render unconvertable
+  ** characters as question marks which can lead to undesired
+  ** side effects (for example in regular expressions).
+  */
+  { "confirmappend",	DT_BOOL, R_NONE, OPTCONFIRMAPPEND, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will prompt for confirmation when appending messages to
+  ** an existing mailbox.
+  */
+  { "confirmcreate",	DT_BOOL, R_NONE, OPTCONFIRMCREATE, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will prompt for confirmation when saving messages to a
+  ** mailbox which does not yet exist before creating it.
+  */
+  { "connect_timeout",	DT_NUM,	R_NONE, UL &ConnectTimeout, 30 },
+  /*
+  ** .pp
+  ** Causes Mutt to timeout a network connection (for IMAP, POP or SMTP) after this
+  ** many seconds if the connection is not able to be established.  A negative
+  ** value causes Mutt to wait indefinitely for the connection attempt to succeed.
+  */
+  { "content_type",	DT_STR, R_NONE, UL &ContentType, UL "text/plain" },
+  /*
+  ** .pp
+  ** Sets the default Content-Type for the body of newly composed messages.
+  */
+  { "copy",		DT_QUAD, R_NONE, OPT_COPY, M_YES },
+  /*
+  ** .pp
+  ** This variable controls whether or not copies of your outgoing messages
+  ** will be saved for later references.  Also see $$record,
+  ** $$save_name, $$force_name and ``$fcc-hook''.
+  */
+  { "pgp_autoencrypt",		DT_SYN,  R_NONE, UL "crypt_autoencrypt", 0 },
+  { "crypt_autoencrypt",	DT_BOOL, R_NONE, OPTCRYPTAUTOENCRYPT, 0 },
+  /*
+  ** .pp
+  ** Setting this variable will cause Mutt to always attempt to PGP
+  ** encrypt outgoing messages.  This is probably only useful in
+  ** connection to the ``$send-hook'' command.  It can be overridden
+  ** by use of the pgp menu, when encryption is not required or
+  ** signing is requested as well.  If $$smime_is_default is \fIset\fP,
+  ** then OpenSSL is used instead to create S/MIME messages and
+  ** settings can be overridden by use of the smime menu instead.
+  ** (Crypto only)
+  */
+  { "crypt_autopgp",	DT_BOOL, R_NONE, OPTCRYPTAUTOPGP, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not mutt may automatically enable
+  ** PGP encryption/signing for messages.  See also $$crypt_autoencrypt,
+  ** $$crypt_replyencrypt,
+  ** $$crypt_autosign, $$crypt_replysign and $$smime_is_default.
+  */
+  { "pgp_autosign", 	DT_SYN,  R_NONE, UL "crypt_autosign", 0 },
+  { "crypt_autosign",	DT_BOOL, R_NONE, OPTCRYPTAUTOSIGN, 0 },
+  /*
+  ** .pp
+  ** Setting this variable will cause Mutt to always attempt to
+  ** cryptographically sign outgoing messages.  This can be overridden
+  ** by use of the pgp menu, when signing is not required or
+  ** encryption is requested as well. If $$smime_is_default is \fIset\fP,
+  ** then OpenSSL is used instead to create S/MIME messages and settings can
+  ** be overridden by use of the smime menu instead of the pgp menu.
+  ** (Crypto only)
+  */
+  { "crypt_autosmime",	DT_BOOL, R_NONE, OPTCRYPTAUTOSMIME, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether or not mutt may automatically enable
+  ** S/MIME encryption/signing for messages. See also $$crypt_autoencrypt,
+  ** $$crypt_replyencrypt,
+  ** $$crypt_autosign, $$crypt_replysign and $$smime_is_default.
+  */
+  { "crypt_confirmhook",	DT_BOOL, R_NONE, OPTCRYPTCONFIRMHOOK, 1 },
+  /*
+  ** .pp
+  ** If set, then you will be prompted for confirmation of keys when using
+  ** the \fIcrypt-hook\fP command.  If unset, no such confirmation prompt will
+  ** be presented.  This is generally considered unsafe, especially where
+  ** typos are concerned.
+  */
+  { "crypt_opportunistic_encrypt", DT_BOOL, R_NONE, OPTCRYPTOPPORTUNISTICENCRYPT, 0 },
+  /*
+  ** .pp
+  ** Setting this variable will cause Mutt to automatically enable and
+  ** disable encryption, based on whether all message recipient keys
+  ** can be located by mutt.
+  ** .pp
+  ** When this option is enabled, mutt will determine the encryption
+  ** setting each time the TO, CC, and BCC lists are edited.  If
+  ** $$edit_headers is set, mutt will also do so each time the message
+  ** is edited.
+  ** .pp
+  ** While this is set, encryption settings can't be manually changed.
+  ** The pgp or smime menus provide an option to disable the option for
+  ** a particular message.
+  ** .pp
+  ** If $$crypt_autoencrypt or $$crypt_replyencrypt enable encryption for
+  ** a message, this option will be disabled for the message.  It can
+  ** be manually re-enabled in the pgp or smime menus.
+  ** (Crypto only)
+   */
+  { "pgp_replyencrypt",		DT_SYN,  R_NONE, UL "crypt_replyencrypt", 1  },
+  { "crypt_replyencrypt",	DT_BOOL, R_NONE, OPTCRYPTREPLYENCRYPT, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, automatically PGP or OpenSSL encrypt replies to messages which are
+  ** encrypted.
+  ** (Crypto only)
+  */
+  { "pgp_replysign",	DT_SYN, R_NONE, UL "crypt_replysign", 0 },
+  { "crypt_replysign",	DT_BOOL, R_NONE, OPTCRYPTREPLYSIGN, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, automatically PGP or OpenSSL sign replies to messages which are
+  ** signed.
+  ** .pp
+  ** \fBNote:\fP this does not work on messages that are encrypted
+  ** \fIand\fP signed!
+  ** (Crypto only)
+  */
+  { "pgp_replysignencrypted",   DT_SYN,  R_NONE, UL "crypt_replysignencrypted", 0},
+  { "crypt_replysignencrypted", DT_BOOL, R_NONE, OPTCRYPTREPLYSIGNENCRYPTED, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, automatically PGP or OpenSSL sign replies to messages
+  ** which are encrypted. This makes sense in combination with
+  ** $$crypt_replyencrypt, because it allows you to sign all
+  ** messages which are automatically encrypted.  This works around
+  ** the problem noted in $$crypt_replysign, that mutt is not able
+  ** to find out whether an encrypted message is also signed.
+  ** (Crypto only)
+  */
+  { "crypt_timestamp", DT_BOOL, R_NONE, OPTCRYPTTIMESTAMP, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will include a time stamp in the lines surrounding
+  ** PGP or S/MIME output, so spoofing such lines is more difficult.
+  ** If you are using colors to mark these lines, and rely on these,
+  ** you may \fIunset\fP this setting.
+  ** (Crypto only)
+  */
+  { "crypt_use_gpgme",  DT_BOOL, R_NONE, OPTCRYPTUSEGPGME, 0 },
+  /*
+  ** .pp
+  ** This variable controls the use of the GPGME-enabled crypto backends.
+  ** If it is \fIset\fP and Mutt was built with gpgme support, the gpgme code for
+  ** S/MIME and PGP will be used instead of the classic code.  Note that
+  ** you need to set this option in .muttrc; it won't have any effect when
+  ** used interactively.
+  */
+  { "crypt_use_pka", DT_BOOL, R_NONE, OPTCRYPTUSEPKA, 0 },
+  /*
+  ** .pp
+  ** Controls whether mutt uses PKA
+  ** (see http://www.g10code.de/docs/pka-intro.de.pdf) during signature
+  ** verification (only supported by the GPGME backend).
+  */
+  { "pgp_verify_sig",   DT_SYN,  R_NONE, UL "crypt_verify_sig", 0},
+  { "crypt_verify_sig",	DT_QUAD, R_NONE, OPT_VERIFYSIG, M_YES },
+  /*
+  ** .pp
+  ** If \fI``yes''\fP, always attempt to verify PGP or S/MIME signatures.
+  ** If \fI``ask-*''\fP, ask whether or not to verify the signature.
+  ** If \fI``no''\fP, never attempt to verify cryptographic signatures.
+  ** (Crypto only)
+  */
+  { "date_format",	DT_STR,	 R_BOTH, UL &DateFmt, UL "!%a, %b %d, %Y at %I:%M:%S%p %Z" },
+  /*
+  ** .pp
+  ** This variable controls the format of the date printed by the ``%d''
+  ** sequence in $$index_format.  This is passed to the \fCstrftime(3)\fP
+  ** function to process the date, see the man page for the proper syntax.
+  ** .pp
+  ** Unless the first character in the string is a bang (``!''), the month
+  ** and week day names are expanded according to the locale specified in
+  ** the variable $$locale. If the first character in the string is a
+  ** bang, the bang is discarded, and the month and week day names in the
+  ** rest of the string are expanded in the \fIC\fP locale (that is in US
+  ** English).
+  */
+  { "default_hook",	DT_STR,	 R_NONE, UL &DefaultHook, UL "~f %s !~P | (~P ~C %s)" },
+  /*
+  ** .pp
+  ** This variable controls how ``$message-hook'', ``$reply-hook'', ``$send-hook'',
+  ** ``$send2-hook'', ``$save-hook'', and ``$fcc-hook'' will
+  ** be interpreted if they are specified with only a simple regexp,
+  ** instead of a matching pattern.  The hooks are expanded when they are
+  ** declared, so a hook will be interpreted according to the value of this
+  ** variable at the time the hook is declared.
+  ** .pp
+  ** The default value matches
+  ** if the message is either from a user matching the regular expression
+  ** given, or if it is from you (if the from address matches
+  ** ``$alternates'') and is to or cc'ed to a user matching the given
+  ** regular expression.
+  */
+  { "delete",		DT_QUAD, R_NONE, OPT_DELETE, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not messages are really deleted when closing or
+  ** synchronizing a mailbox.  If set to \fIyes\fP, messages marked for
+  ** deleting will automatically be purged without prompting.  If set to
+  ** \fIno\fP, messages marked for deletion will be kept in the mailbox.
+  */
+  { "delete_untag",	DT_BOOL, R_NONE, OPTDELETEUNTAG, 1 },
+  /*
+  ** .pp
+  ** If this option is \fIset\fP, mutt will untag messages when marking them
+  ** for deletion.  This applies when you either explicitly delete a message,
+  ** or when you save it to another folder.
+  */
+  { "digest_collapse",	DT_BOOL, R_NONE, OPTDIGESTCOLLAPSE, 1},
+  /*
+  ** .pp
+  ** If this option is \fIset\fP, mutt's received-attachments menu will not show the subparts of
+  ** individual messages in a multipart/digest.  To see these subparts, press ``v'' on that menu.
+  */
+  { "display_filter",	DT_PATH, R_PAGER, UL &DisplayFilter, UL "" },
+  /*
+  ** .pp
+  ** When set, specifies a command used to filter messages.  When a message
+  ** is viewed it is passed as standard input to $$display_filter, and the
+  ** filtered message is read from the standard output.
+  */
+#if defined(DL_STANDALONE) && defined(USE_DOTLOCK)
+  { "dotlock_program",  DT_PATH, R_NONE, UL &MuttDotlock, UL BINDIR "/mutt_dotlock" },
+  /*
+  ** .pp
+  ** Contains the path of the \fCmutt_dotlock(8)\fP binary to be used by
+  ** mutt.
+  */
+#endif
+  { "dsn_notify",	DT_STR,	 R_NONE, UL &DsnNotify, UL "" },
+  /*
+  ** .pp
+  ** This variable sets the request for when notification is returned.  The
+  ** string consists of a comma separated list (no spaces!) of one or more
+  ** of the following: \fInever\fP, to never request notification,
+  ** \fIfailure\fP, to request notification on transmission failure,
+  ** \fIdelay\fP, to be notified of message delays, \fIsuccess\fP, to be
+  ** notified of successful transmission.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set dsn_notify="failure,delay"
+  ** .te
+  ** .pp
+  ** \fBNote:\fP when using $$sendmail for delivery, you should not enable
+  ** this unless you are either using Sendmail 8.8.x or greater or a MTA
+  ** providing a \fCsendmail(1)\fP-compatible interface supporting the \fC-N\fP option
+  ** for DSN. For SMTP delivery, DSN support is auto-detected so that it
+  ** depends on the server whether DSN will be used or not.
+  */
+  { "dsn_return",	DT_STR,	 R_NONE, UL &DsnReturn, UL "" },
+  /*
+  ** .pp
+  ** This variable controls how much of your message is returned in DSN
+  ** messages.  It may be set to either \fIhdrs\fP to return just the
+  ** message header, or \fIfull\fP to return the full message.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set dsn_return=hdrs
+  ** .te
+  ** .pp
+  ** \fBNote:\fP when using $$sendmail for delivery, you should not enable
+  ** this unless you are either using Sendmail 8.8.x or greater or a MTA
+  ** providing a \fCsendmail(1)\fP-compatible interface supporting the \fC-R\fP option
+  ** for DSN. For SMTP delivery, DSN support is auto-detected so that it
+  ** depends on the server whether DSN will be used or not.
+  */
+  { "duplicate_threads",	DT_BOOL, R_RESORT|R_RESORT_INIT|R_INDEX, OPTDUPTHREADS, 1 },
+  /*
+  ** .pp
+  ** This variable controls whether mutt, when $$sort is set to \fIthreads\fP, threads
+  ** messages with the same Message-Id together.  If it is \fIset\fP, it will indicate
+  ** that it thinks they are duplicates of each other with an equals sign
+  ** in the thread tree.
+  */
+  { "edit_headers",	DT_BOOL, R_NONE, OPTEDITHDRS, 0 },
+  /*
+  ** .pp
+  ** This option allows you to edit the header of your outgoing messages
+  ** along with the body of your message.
+  ** .pp
+  ** \fBNote\fP that changes made to the References: and Date: headers are
+  ** ignored for interoperability reasons.
+  */
+  { "edit_hdrs",	DT_SYN,  R_NONE, UL "edit_headers", 0 },
+  /*
+  */
+  { "editor",		DT_PATH, R_NONE, UL &Editor, 0 },
+  /*
+  ** .pp
+  ** This variable specifies which editor is used by mutt.
+  ** It defaults to the value of the \fC$$$VISUAL\fP, or \fC$$$EDITOR\fP, environment
+  ** variable, or to the string ``vi'' if neither of those are set.
+  ** .pp
+  ** The \fC$$editor\fP string may contain a \fI%s\fP escape, which will be replaced by the name
+  ** of the file to be edited.  If the \fI%s\fP escape does not appear in \fC$$editor\fP, a
+  ** space and the name to be edited are appended.
+  ** .pp
+  ** The resulting string is then executed by running
+  ** .ts
+  ** sh -c 'string'
+  ** .te
+  ** .pp
+  ** where \fIstring\fP is the expansion of \fC$$editor\fP described above.
+  */
+  { "encode_from",	DT_BOOL, R_NONE, OPTENCODEFROM, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will quoted-printable encode messages when
+  ** they contain the string ``From '' (note the trailing space) in the beginning of a line.
+  ** This is useful to avoid the tampering certain mail delivery and transport
+  ** agents tend to do with messages (in order to prevent tools from
+  ** misinterpreting the line as a mbox message separator).
+  */
+#if defined(USE_SSL_OPENSSL)
+  { "entropy_file",	DT_PATH, R_NONE, UL &SslEntropyFile, 0 },
+  /*
+  ** .pp
+  ** The file which includes random data that is used to initialize SSL
+  ** library functions.
+  */
+#endif
+  { "envelope_from_address", DT_ADDR, R_NONE, UL &EnvFrom, 0 },
+  /*
+  ** .pp
+  ** Manually sets the \fIenvelope\fP sender for outgoing messages.
+  ** This value is ignored if $$use_envelope_from is \fIunset\fP.
+  */
+  { "escape",		DT_STR,	 R_NONE, UL &EscChar, UL "~" },
+  /*
+  ** .pp
+  ** Escape character to use for functions in the built-in editor.
+  */
+  { "fast_reply",	DT_BOOL, R_NONE, OPTFASTREPLY, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, the initial prompt for recipients and subject are skipped
+  ** when replying to messages, and the initial prompt for subject is
+  ** skipped when forwarding messages.
+  ** .pp
+  ** \fBNote:\fP this variable has no effect when the $$autoedit
+  ** variable is \fIset\fP.
+  */
+  { "fcc_attach",	DT_QUAD, R_NONE, OPT_FCCATTACH, M_YES },
+  /*
+  ** .pp
+  ** This variable controls whether or not attachments on outgoing messages
+  ** are saved along with the main body of your message.
+  */
+  { "fcc_clear",	DT_BOOL, R_NONE, OPTFCCCLEAR, 0 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, FCCs will be stored unencrypted and
+  ** unsigned, even when the actual message is encrypted and/or
+  ** signed.
+  ** (PGP only)
+  */
+  { "folder",		DT_PATH, R_NONE, UL &Maildir, UL "~/Mail" },
+  /*
+  ** .pp
+  ** Specifies the default location of your mailboxes.  A ``+'' or ``='' at the
+  ** beginning of a pathname will be expanded to the value of this
+  ** variable.  Note that if you change this variable (from the default)
+  ** value you need to make sure that the assignment occurs \fIbefore\fP
+  ** you use ``+'' or ``='' for any other variables since expansion takes place
+  ** when handling the ``$mailboxes'' command.
+  */
+  { "folder_format",	DT_STR,	 R_INDEX, UL &FolderFormat, UL "%2C %t %N %F %2l %-8.8u %-8.8g %8s %d %f" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the file browser display to your
+  ** personal taste.  This string is similar to $$index_format, but has
+  ** its own set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %C  .dd current file number
+  ** .dt %d  .dd date/time folder was last modified
+  ** .dt %D  .dd date/time folder was last modified using $$date_format.
+  ** .dt %f  .dd filename (``/'' is appended to directory names,
+  **             ``@'' to symbolic links and ``*'' to executable
+  **             files)
+  ** .dt %F  .dd file permissions
+  ** .dt %g  .dd group name (or numeric gid, if missing)
+  ** .dt %l  .dd number of hard links
+  ** .dt %N  .dd N if folder has new mail, blank otherwise
+  ** .dt %s  .dd size in bytes
+  ** .dt %t  .dd ``*'' if the file is tagged, blank otherwise
+  ** .dt %u  .dd owner name (or numeric uid, if missing)
+  ** .dt %>X .dd right justify the rest of the string and pad with character ``X''
+  ** .dt %|X .dd pad to the end of the line with character ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  */
+  { "followup_to",	DT_BOOL, R_NONE, OPTFOLLOWUPTO, 1 },
+  /*
+  ** .pp
+  ** Controls whether or not the ``Mail-Followup-To:'' header field is
+  ** generated when sending mail.  When \fIset\fP, Mutt will generate this
+  ** field when you are replying to a known mailing list, specified with
+  ** the ``$subscribe'' or ``$lists'' commands.
+  ** .pp
+  ** This field has two purposes.  First, preventing you from
+  ** receiving duplicate copies of replies to messages which you send
+  ** to mailing lists, and second, ensuring that you do get a reply
+  ** separately for any messages sent to known lists to which you are
+  ** not subscribed.
+  ** .pp
+  ** The header will contain only the list's address
+  ** for subscribed lists, and both the list address and your own
+  ** email address for unsubscribed lists.  Without this header, a
+  ** group reply to your message sent to a subscribed list will be
+  ** sent to both the list and your address, resulting in two copies
+  ** of the same email for you.
+  */
+  { "force_name",	DT_BOOL, R_NONE, OPTFORCENAME, 0 },
+  /*
+  ** .pp
+  ** This variable is similar to $$save_name, except that Mutt will
+  ** store a copy of your outgoing message by the username of the address
+  ** you are sending to even if that mailbox does not exist.
+  ** .pp
+  ** Also see the $$record variable.
+  */
+  { "forward_decode",	DT_BOOL, R_NONE, OPTFORWDECODE, 1 },
+  /*
+  ** .pp
+  ** Controls the decoding of complex MIME messages into \fCtext/plain\fP when
+  ** forwarding a message.  The message header is also RFC2047 decoded.
+  ** This variable is only used, if $$mime_forward is \fIunset\fP,
+  ** otherwise $$mime_forward_decode is used instead.
+  */
+  { "forw_decode",	DT_SYN,  R_NONE, UL "forward_decode", 0 },
+  /*
+  */
+  { "forward_decrypt",	DT_BOOL, R_NONE, OPTFORWDECRYPT, 1 },
+  /*
+  ** .pp
+  ** Controls the handling of encrypted messages when forwarding a message.
+  ** When \fIset\fP, the outer layer of encryption is stripped off.  This
+  ** variable is only used if $$mime_forward is \fIset\fP and
+  ** $$mime_forward_decode is \fIunset\fP.
+  ** (PGP only)
+  */
+  { "forw_decrypt",	DT_SYN,  R_NONE, UL "forward_decrypt", 0 },
+  /*
+  */
+  { "forward_edit",	DT_QUAD, R_NONE, OPT_FORWEDIT, M_YES },
+  /*
+  ** .pp
+  ** This quadoption controls whether or not the user is automatically
+  ** placed in the editor when forwarding messages.  For those who always want
+  ** to forward with no modification, use a setting of ``no''.
+  */
+  { "forward_format",	DT_STR,	 R_NONE, UL &ForwFmt, UL "[%a: %s]" },
+  /*
+  ** .pp
+  ** This variable controls the default subject when forwarding a message.
+  ** It uses the same format sequences as the $$index_format variable.
+  */
+  { "forw_format",	DT_SYN,  R_NONE, UL "forward_format", 0 },
+  /*
+  */
+  { "forward_quote",	DT_BOOL, R_NONE, OPTFORWQUOTE, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, forwarded messages included in the main body of the
+  ** message (when $$mime_forward is \fIunset\fP) will be quoted using
+  ** $$indent_string.
+  */
+  { "forw_quote",	DT_SYN,  R_NONE, UL "forward_quote", 0 },
+  /*
+  */
+  { "from",		DT_ADDR, R_NONE, UL &From, UL 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, this variable contains a default from address.  It
+  ** can be overridden using ``$my_hdr'' (including from a ``$send-hook'') and
+  ** $$reverse_name.  This variable is ignored if $$use_from is \fIunset\fP.
+  ** .pp
+  ** This setting defaults to the contents of the environment variable \fC$$$EMAIL\fP.
+  */
+  { "gecos_mask",	DT_RX,	 R_NONE, UL &GecosMask, UL "^[^,]*" },
+  /*
+  ** .pp
+  ** A regular expression used by mutt to parse the GECOS field of a password
+  ** entry when expanding the alias.  The default value
+  ** will return the string up to the first ``,'' encountered.
+  ** If the GECOS field contains a string like ``lastname, firstname'' then you
+  ** should set it to ``\fC.*\fP''.
+  ** .pp
+  ** This can be useful if you see the following behavior: you address an e-mail
+  ** to user ID ``stevef'' whose full name is ``Steve Franklin''.  If mutt expands
+  ** ``stevef'' to ``"Franklin" stevef@foo.bar'' then you should set the $$gecos_mask to
+  ** a regular expression that will match the whole name so mutt will expand
+  ** ``Franklin'' to ``Franklin, Steve''.
+  */
+  { "hdr_format",	DT_SYN,  R_NONE, UL "index_format", 0 },
+  /*
+  */
+  { "hdrs",		DT_BOOL, R_NONE, OPTHDRS, 1 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, the header fields normally added by the ``$my_hdr''
+  ** command are not created.  This variable \fImust\fP be unset before
+  ** composing a new message or replying in order to take effect.  If \fIset\fP,
+  ** the user defined header fields are added to every new message.
+  */
+  { "header",		DT_BOOL, R_NONE, OPTHEADER, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, this variable causes Mutt to include the header
+  ** of the message you are replying to into the edit buffer.
+  ** The $$weed setting applies.
+  */
+#ifdef USE_HCACHE
+  { "header_cache", DT_PATH, R_NONE, UL &HeaderCache, 0 },
+  /*
+  ** .pp
+  ** This variable points to the header cache database.
+  ** If pointing to a directory Mutt will contain a header cache
+  ** database file per folder, if pointing to a file that file will
+  ** be a single global header cache. By default it is \fIunset\fP so no header
+  ** caching will be used.
+  ** .pp
+  ** Header caching can greatly improve speed when opening POP, IMAP
+  ** MH or Maildir folders, see ``$caching'' for details.
+  */
+#if defined(HAVE_QDBM) || defined(HAVE_TC)
+  { "header_cache_compress", DT_BOOL, R_NONE, OPTHCACHECOMPRESS, 1 },
+  /*
+  ** .pp
+  ** When mutt is compiled with qdbm or tokyocabinet as header cache backend,
+  ** this option determines whether the database will be compressed.
+  ** Compression results in database files roughly being one fifth
+  ** of the usual diskspace, but the decompression can result in a
+  ** slower opening of cached folder(s) which in general is still
+  ** much faster than opening non header cached folders.
+  */
+#endif /* HAVE_QDBM */
+#if defined(HAVE_GDBM) || defined(HAVE_DB4)
+  { "header_cache_pagesize", DT_STR, R_NONE, UL &HeaderCachePageSize, UL "16384" },
+  /*
+  ** .pp
+  ** When mutt is compiled with either gdbm or bdb4 as the header cache backend,
+  ** this option changes the database page size.  Too large or too small
+  ** values can waste space, memory, or CPU time. The default should be more
+  ** or less optimal for most use cases.
+  */
+#endif /* HAVE_GDBM || HAVE_DB4 */
+#endif /* USE_HCACHE */
+  { "help",		DT_BOOL, R_BOTH, OPTHELP, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, help lines describing the bindings for the major functions
+  ** provided by each menu are displayed on the first line of the screen.
+  ** .pp
+  ** \fBNote:\fP The binding will not be displayed correctly if the
+  ** function is bound to a sequence rather than a single keystroke.  Also,
+  ** the help line may not be updated if a binding is changed while Mutt is
+  ** running.  Since this variable is primarily aimed at new users, neither
+  ** of these should present a major problem.
+  */
+  { "hidden_host",	DT_BOOL, R_NONE, OPTHIDDENHOST, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will skip the host name part of $$hostname variable
+  ** when adding the domain part to addresses.  This variable does not
+  ** affect the generation of Message-IDs, and it will not lead to the
+  ** cut-off of first-level domains.
+  */
+  { "hide_limited",	DT_BOOL, R_TREE|R_INDEX, OPTHIDELIMITED, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not show the presence of messages that are hidden
+  ** by limiting, in the thread tree.
+  */
+  { "hide_missing",	DT_BOOL, R_TREE|R_INDEX, OPTHIDEMISSING, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not show the presence of missing messages in the
+  ** thread tree.
+  */
+  { "hide_thread_subject", DT_BOOL, R_TREE|R_INDEX, OPTHIDETHREADSUBJECT, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not show the subject of messages in the thread
+  ** tree that have the same subject as their parent or closest previously
+  ** displayed sibling.
+  */
+  { "hide_top_limited",	DT_BOOL, R_TREE|R_INDEX, OPTHIDETOPLIMITED, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not show the presence of messages that are hidden
+  ** by limiting, at the top of threads in the thread tree.  Note that when
+  ** $$hide_limited is \fIset\fP, this option will have no effect.
+  */
+  { "hide_top_missing",	DT_BOOL, R_TREE|R_INDEX, OPTHIDETOPMISSING, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not show the presence of missing messages at the
+  ** top of threads in the thread tree.  Note that when $$hide_missing is
+  ** \fIset\fP, this option will have no effect.
+  */
+  { "history",		DT_NUM,	 R_NONE, UL &HistSize, 10 },
+  /*
+  ** .pp
+  ** This variable controls the size (in number of strings remembered) of
+  ** the string history buffer per category. The buffer is cleared each time the
+  ** variable is set.
+  */
+  { "history_file",     DT_PATH, R_NONE, UL &HistFile, UL "~/.mutthistory" },
+  /*
+  ** .pp
+  ** The file in which Mutt will save its history.
+  */
+  { "honor_disposition", DT_BOOL, R_NONE, OPTHONORDISP, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will not display attachments with a
+  ** disposition of ``attachment'' inline even if it could
+  ** render the part to plain text. These MIME parts can only
+  ** be viewed from the attachment menu.
+  ** .pp
+  ** If \fIunset\fP, Mutt will render all MIME parts it can
+  ** properly transform to plain text.
+  */
+  { "honor_followup_to", DT_QUAD, R_NONE, OPT_MFUPTO, M_YES },
+  /*
+  ** .pp
+  ** This variable controls whether or not a Mail-Followup-To header is
+  ** honored when group-replying to a message.
+  */
+  { "hostname",		DT_STR,	 R_NONE, UL &Fqdn, 0 },
+  /*
+  ** .pp
+  ** Specifies the fully-qualified hostname of the system mutt is running on
+  ** containing the host's name and the DNS domain it belongs to. It is used
+  ** as the domain part (after ``@'') for local email addresses as well as
+  ** Message-Id headers.
+  ** .pp
+  ** Its value is determined at startup as follows: If the node's name
+  ** as returned by the \fCuname(3)\fP function contains the hostname and the
+  ** domain, these are used to construct $$hostname. If there is no
+  ** domain part returned, Mutt will look for a ``domain'' or ``search''
+  ** line in \fC/etc/resolv.conf\fP to determine the domain. Optionally, Mutt
+  ** can be compiled with a fixed domain name in which case a detected
+  ** one is not used.
+  ** .pp
+  ** Also see $$use_domain and $$hidden_host.
+  */
+  { "ignore_linear_white_space",    DT_BOOL, R_NONE, OPTIGNORELWS, 0 },
+  /*
+  ** .pp
+  ** This option replaces linear-white-space between encoded-word
+  ** and text to a single space to prevent the display of MIME-encoded
+  ** ``Subject:'' field from being divided into multiple lines.
+  */
+  { "ignore_list_reply_to", DT_BOOL, R_NONE, OPTIGNORELISTREPLYTO, 0 },
+  /*
+  ** .pp
+  ** Affects the behavior of the \fC<reply>\fP function when replying to
+  ** messages from mailing lists (as defined by the ``$subscribe'' or
+  ** ``$lists'' commands).  When \fIset\fP, if the ``Reply-To:'' field is
+  ** set to the same value as the ``To:'' field, Mutt assumes that the
+  ** ``Reply-To:'' field was set by the mailing list to automate responses
+  ** to the list, and will ignore this field.  To direct a response to the
+  ** mailing list when this option is \fIset\fP, use the \fC$<list-reply>\fP
+  ** function; \fC<group-reply>\fP will reply to both the sender and the
+  ** list.
+  */
+#ifdef USE_IMAP
+  { "imap_authenticators", DT_STR, R_NONE, UL &ImapAuthenticators, UL 0 },
+  /*
+  ** .pp
+  ** This is a colon-delimited list of authentication methods mutt may
+  ** attempt to use to log in to an IMAP server, in the order mutt should
+  ** try them.  Authentication methods are either ``login'' or the right
+  ** side of an IMAP ``AUTH=xxx'' capability string, e.g. ``digest-md5'', ``gssapi''
+  ** or ``cram-md5''. This option is case-insensitive. If it's
+  ** \fIunset\fP (the default) mutt will try all available methods,
+  ** in order from most-secure to least-secure.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set imap_authenticators="gssapi:cram-md5:login"
+  ** .te
+  ** .pp
+  ** \fBNote:\fP Mutt will only fall back to other authentication methods if
+  ** the previous methods are unavailable. If a method is available but
+  ** authentication fails, mutt will not connect to the IMAP server.
+  */
+  { "imap_check_subscribed",  DT_BOOL, R_NONE, OPTIMAPCHECKSUBSCRIBED, 0 },
+  /*
+   ** .pp
+   ** When \fIset\fP, mutt will fetch the set of subscribed folders from
+   ** your server on connection, and add them to the set of mailboxes
+   ** it polls for new mail just as if you had issued individual ``$mailboxes''
+   ** commands.
+   */
+  { "imap_delim_chars",		DT_STR, R_NONE, UL &ImapDelimChars, UL "/." },
+  /*
+  ** .pp
+  ** This contains the list of characters which you would like to treat
+  ** as folder separators for displaying IMAP paths. In particular it
+  ** helps in using the ``='' shortcut for your \fIfolder\fP variable.
+  */
+  { "imap_headers",	DT_STR, R_INDEX, UL &ImapHeaders, UL 0},
+  /*
+  ** .pp
+  ** Mutt requests these header fields in addition to the default headers
+  ** (``Date:'', ``From:'', ``Subject:'', ``To:'', ``Cc:'', ``Message-Id:'',
+  ** ``References:'', ``Content-Type:'', ``Content-Description:'', ``In-Reply-To:'',
+  ** ``Reply-To:'', ``Lines:'', ``List-Post:'', ``X-Label:'') from IMAP
+  ** servers before displaying the index menu. You may want to add more
+  ** headers for spam detection.
+  ** .pp
+  ** \fBNote:\fP This is a space separated list, items should be uppercase
+  ** and not contain the colon, e.g. ``X-BOGOSITY X-SPAM-STATUS'' for the
+  ** ``X-Bogosity:'' and ``X-Spam-Status:'' header fields.
+  */
+  { "imap_idle",                DT_BOOL, R_NONE, OPTIMAPIDLE, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will attempt to use the IMAP IDLE extension
+  ** to check for new mail in the current mailbox. Some servers
+  ** (dovecot was the inspiration for this option) react badly
+  ** to mutt's implementation. If your connection seems to freeze
+  ** up periodically, try unsetting this.
+  */
+  { "imap_keepalive",           DT_NUM,  R_NONE, UL &ImapKeepalive, 300 },
+  /*
+  ** .pp
+  ** This variable specifies the maximum amount of time in seconds that mutt
+  ** will wait before polling open IMAP connections, to prevent the server
+  ** from closing them before mutt has finished with them. The default is
+  ** well within the RFC-specified minimum amount of time (30 minutes) before
+  ** a server is allowed to do this, but in practice the RFC does get
+  ** violated every now and then. Reduce this number if you find yourself
+  ** getting disconnected from your IMAP server due to inactivity.
+  */
+  { "imap_list_subscribed",	DT_BOOL, R_NONE, OPTIMAPLSUB, 0 },
+  /*
+  ** .pp
+  ** This variable configures whether IMAP folder browsing will look for
+  ** only subscribed folders or all folders.  This can be toggled in the
+  ** IMAP browser with the \fC<toggle-subscribed>\fP function.
+  */
+  { "imap_login",	DT_STR,  R_NONE, UL &ImapLogin, UL 0 },
+  /*
+  ** .pp
+  ** Your login name on the IMAP server.
+  ** .pp
+  ** This variable defaults to the value of $$imap_user.
+  */
+  { "imap_pass", 	DT_STR,  R_NONE, UL &ImapPass, UL 0 },
+  /*
+  ** .pp
+  ** Specifies the password for your IMAP account.  If \fIunset\fP, Mutt will
+  ** prompt you for your password when you invoke the \fC<imap-fetch-mail>\fP function
+  ** or try to open an IMAP folder.
+  ** .pp
+  ** \fBWarning\fP: you should only use this option when you are on a
+  ** fairly secure machine, because the superuser can read your muttrc even
+  ** if you are the only one who can read the file.
+  */
+  { "imap_passive",		DT_BOOL, R_NONE, OPTIMAPPASSIVE, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will not open new IMAP connections to check for new
+  ** mail.  Mutt will only check for new mail over existing IMAP
+  ** connections.  This is useful if you don't want to be prompted to
+  ** user/password pairs on mutt invocation, or if opening the connection
+  ** is slow.
+  */
+  { "imap_peek", DT_BOOL, R_NONE, OPTIMAPPEEK, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will avoid implicitly marking your mail as read whenever
+  ** you fetch a message from the server. This is generally a good thing,
+  ** but can make closing an IMAP folder somewhat slower. This option
+  ** exists to appease speed freaks.
+  */
+  { "imap_pipeline_depth", DT_NUM,  R_NONE, UL &ImapPipelineDepth, 15 },
+  /*
+  ** .pp
+  ** Controls the number of IMAP commands that may be queued up before they
+  ** are sent to the server. A deeper pipeline reduces the amount of time
+  ** mutt must wait for the server, and can make IMAP servers feel much
+  ** more responsive. But not all servers correctly handle pipelined commands,
+  ** so if you have problems you might want to try setting this variable to 0.
+  ** .pp
+  ** \fBNote:\fP Changes to this variable have no effect on open connections.
+  */
+  { "imap_servernoise",		DT_BOOL, R_NONE, OPTIMAPSERVERNOISE, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will display warning messages from the IMAP
+  ** server as error messages. Since these messages are often
+  ** harmless, or generated due to configuration problems on the
+  ** server which are out of the users' hands, you may wish to suppress
+  ** them at some point.
+  */
+  { "imap_user",	DT_STR,  R_NONE, UL &ImapUser, UL 0 },
+  /*
+  ** .pp
+  ** The name of the user whose mail you intend to access on the IMAP
+  ** server.
+  ** .pp
+  ** This variable defaults to your user name on the local machine.
+  */
+#endif
+  { "implicit_autoview", DT_BOOL,R_NONE, OPTIMPLICITAUTOVIEW, 0},
+  /*
+  ** .pp
+  ** If set to ``yes'', mutt will look for a mailcap entry with the
+  ** ``\fCcopiousoutput\fP'' flag set for \fIevery\fP MIME attachment it doesn't have
+  ** an internal viewer defined for.  If such an entry is found, mutt will
+  ** use the viewer defined in that entry to convert the body part to text
+  ** form.
+  */
+  { "include",		DT_QUAD, R_NONE, OPT_INCLUDE, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not a copy of the message(s) you are replying to
+  ** is included in your reply.
+  */
+  { "include_onlyfirst",	DT_BOOL, R_NONE, OPTINCLUDEONLYFIRST, 0},
+  /*
+  ** .pp
+  ** Controls whether or not Mutt includes only the first attachment
+  ** of the message you are replying.
+  */
+  { "indent_string",	DT_STR,	 R_NONE, UL &Prefix, UL "> " },
+  /*
+  ** .pp
+  ** Specifies the string to prepend to each line of text quoted in a
+  ** message to which you are replying.  You are strongly encouraged not to
+  ** change this value, as it tends to agitate the more fanatical netizens.
+  ** .pp
+  ** The value of this option is ignored if $$text_flowed is set, too because
+  ** the quoting mechanism is strictly defined for format=flowed.
+  ** .pp
+  ** This option is a format string, please see the description of
+  ** $$index_format for supported \fCprintf(3)\fP-style sequences.
+  */
+  { "indent_str",	DT_SYN,  R_NONE, UL "indent_string", 0 },
+  /*
+  */
+  { "index_format",	DT_STR,	 R_BOTH, UL &HdrFmt, UL "%4C %Z %{%b %d} %-15.15L (%?l?%4l&%4c?) %s" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the message index display to
+  ** your personal taste.
+  ** .pp
+  ** ``Format strings'' are similar to the strings used in the C
+  ** function \fCprintf(3)\fP to format output (see the man page for more details).
+  ** The following sequences are defined in Mutt:
+  ** .dl
+  ** .dt %a .dd address of the author
+  ** .dt %A .dd reply-to address (if present; otherwise: address of author)
+  ** .dt %b .dd filename of the original message folder (think mailbox)
+  ** .dt %B .dd the list to which the letter was sent, or else the folder name (%b).
+  ** .dt %c .dd number of characters (bytes) in the message
+  ** .dt %C .dd current message number
+  ** .dt %d .dd date and time of the message in the format specified by
+  **            $$date_format converted to sender's time zone
+  ** .dt %D .dd date and time of the message in the format specified by
+  **            $$date_format converted to the local time zone
+  ** .dt %e .dd current message number in thread
+  ** .dt %E .dd number of messages in current thread
+  ** .dt %f .dd sender (address + real name), either From: or Return-Path:
+  ** .dt %F .dd author name, or recipient name if the message is from you
+  ** .dt %H .dd spam attribute(s) of this message
+  ** .dt %i .dd message-id of the current message
+  ** .dt %l .dd number of lines in the message (does not work with maildir,
+  **            mh, and possibly IMAP folders)
+  ** .dt %L .dd If an address in the ``To:'' or ``Cc:'' header field matches an address
+  **            defined by the users ``$subscribe'' command, this displays
+  **            "To <list-name>", otherwise the same as %F.
+  ** .dt %m .dd total number of message in the mailbox
+  ** .dt %M .dd number of hidden messages if the thread is collapsed.
+  ** .dt %N .dd message score
+  ** .dt %n .dd author's real name (or address if missing)
+  ** .dt %O .dd original save folder where mutt would formerly have
+  **            stashed the message: list name or recipient name
+  **            if not sent to a list
+  ** .dt %P .dd progress indicator for the built-in pager (how much of the file has been displayed)
+  ** .dt %s .dd subject of the message
+  ** .dt %S .dd status of the message (``N''/``D''/``d''/``!''/``r''/\(as)
+  ** .dt %t .dd ``To:'' field (recipients)
+  ** .dt %T .dd the appropriate character from the $$to_chars string
+  ** .dt %u .dd user (login) name of the author
+  ** .dt %v .dd first name of the author, or the recipient if the message is from you
+  ** .dt %X .dd number of attachments
+  **            (please see the ``$attachments'' section for possible speed effects)
+  ** .dt %y .dd ``X-Label:'' field, if present
+  ** .dt %Y .dd ``X-Label:'' field, if present, and \fI(1)\fP not at part of a thread tree,
+  **            \fI(2)\fP at the top of a thread, or \fI(3)\fP ``X-Label:'' is different from
+  **            preceding message's ``X-Label:''.
+  ** .dt %Z .dd message status flags
+  ** .dt %{fmt} .dd the date and time of the message is converted to sender's
+  **                time zone, and ``fmt'' is expanded by the library function
+  **                \fCstrftime(3)\fP; a leading bang disables locales
+  ** .dt %[fmt] .dd the date and time of the message is converted to the local
+  **                time zone, and ``fmt'' is expanded by the library function
+  **                \fCstrftime(3)\fP; a leading bang disables locales
+  ** .dt %(fmt) .dd the local date and time when the message was received.
+  **                ``fmt'' is expanded by the library function \fCstrftime(3)\fP;
+  **                a leading bang disables locales
+  ** .dt %<fmt> .dd the current local time. ``fmt'' is expanded by the library
+  **                function \fCstrftime(3)\fP; a leading bang disables locales.
+  ** .dt %>X    .dd right justify the rest of the string and pad with character ``X''
+  ** .dt %|X    .dd pad to the end of the line with character ``X''
+  ** .dt %*X    .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** ``Soft-fill'' deserves some explanation: Normal right-justification
+  ** will print everything to the left of the ``%>'', displaying padding and
+  ** whatever lies to the right only if there's room. By contrast,
+  ** soft-fill gives priority to the right-hand side, guaranteeing space
+  ** to display it and showing padding only if there's still room. If
+  ** necessary, soft-fill will eat text leftwards to make room for
+  ** rightward text.
+  ** .pp
+  ** Note that these expandos are supported in
+  ** ``$save-hook'', ``$fcc-hook'' and ``$fcc-save-hook'', too.
+  */
+  { "ispell",		DT_PATH, R_NONE, UL &Ispell, UL ISPELL },
+  /*
+  ** .pp
+  ** How to invoke ispell (GNU's spell-checking software).
+  */
+  { "keep_flagged", DT_BOOL, R_NONE, OPTKEEPFLAGGED, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, read messages marked as flagged will not be moved
+  ** from your spool mailbox to your $$mbox mailbox, or as a result of
+  ** a ``$mbox-hook'' command.
+  */
+  { "locale",		DT_STR,  R_BOTH, UL &Locale, UL "C" },
+  /*
+  ** .pp
+  ** The locale used by \fCstrftime(3)\fP to format dates. Legal values are
+  ** the strings your system accepts for the locale environment variable \fC$$$LC_TIME\fP.
+  */
+  { "mail_check",	DT_NUM,  R_NONE, UL &BuffyTimeout, 5 },
+  /*
+  ** .pp
+  ** This variable configures how often (in seconds) mutt should look for
+  ** new mail. Also see the $$timeout variable.
+  */
+  { "mail_check_recent",DT_BOOL, R_NONE, OPTMAILCHECKRECENT, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will only notify you about new mail that has been received
+  ** since the last time you opened the mailbox.  When \fIunset\fP, Mutt will notify you
+  ** if any new mail exists in the mailbox, regardless of whether you have visited it
+  ** recently.
+  ** .pp
+  ** When \fI$$mark_old\fP is set, Mutt does not consider the mailbox to contain new
+  ** mail if only old messages exist.
+  */
+  { "mailcap_path",	DT_STR,	 R_NONE, UL &MailcapPath, 0 },
+  /*
+  ** .pp
+  ** This variable specifies which files to consult when attempting to
+  ** display MIME bodies not directly supported by Mutt.
+  */
+  { "mailcap_sanitize",	DT_BOOL, R_NONE, OPTMAILCAPSANITIZE, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will restrict possible characters in mailcap % expandos
+  ** to a well-defined set of safe characters.  This is the safe setting,
+  ** but we are not sure it doesn't break some more advanced MIME stuff.
+  ** .pp
+  ** \fBDON'T CHANGE THIS SETTING UNLESS YOU ARE REALLY SURE WHAT YOU ARE
+  ** DOING!\fP
+  */
+#ifdef USE_HCACHE
+  { "maildir_header_cache_verify", DT_BOOL, R_NONE, OPTHCACHEVERIFY, 1 },
+  /*
+  ** .pp
+  ** Check for Maildir unaware programs other than mutt having modified maildir
+  ** files when the header cache is in use.  This incurs one \fCstat(2)\fP per
+  ** message every time the folder is opened (which can be very slow for NFS
+  ** folders).
+  */
+#endif
+  { "maildir_trash", DT_BOOL, R_NONE, OPTMAILDIRTRASH, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, messages marked as deleted will be saved with the maildir
+  ** trashed flag instead of unlinked.  \fBNote:\fP this only applies
+  ** to maildir-style mailboxes.  Setting it will have no effect on other
+  ** mailbox types.
+  */
+  { "maildir_check_cur", DT_BOOL, R_NONE, OPTMAILDIRCHECKCUR, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will poll both the new and cur directories of
+  ** a maildir folder for new messages.  This might be useful if other
+  ** programs interacting with the folder (e.g. dovecot) are moving new
+  ** messages to the cur directory.  Note that setting this option may
+  ** slow down polling for new messages in large folders, since mutt has
+  ** to scan all cur messages.
+  */
+  { "mark_old",		DT_BOOL, R_BOTH, OPTMARKOLD, 1 },
+  /*
+  ** .pp
+  ** Controls whether or not mutt marks \fInew\fP \fBunread\fP
+  ** messages as \fIold\fP if you exit a mailbox without reading them.
+  ** With this option \fIset\fP, the next time you start mutt, the messages
+  ** will show up with an ``O'' next to them in the index menu,
+  ** indicating that they are old.
+  */
+  { "markers",		DT_BOOL, R_PAGER, OPTMARKERS, 1 },
+  /*
+  ** .pp
+  ** Controls the display of wrapped lines in the internal pager. If set, a
+  ** ``+'' marker is displayed at the beginning of wrapped lines.
+  ** .pp
+  ** Also see the $$smart_wrap variable.
+  */
+  { "mask",		DT_RX,	 R_NONE, UL &Mask, UL "!^\\.[^.]" },
+  /*
+  ** .pp
+  ** A regular expression used in the file browser, optionally preceded by
+  ** the \fInot\fP operator ``!''.  Only files whose names match this mask
+  ** will be shown. The match is always case-sensitive.
+  */
+  { "mbox",		DT_PATH, R_BOTH, UL &Inbox, UL "~/mbox" },
+  /*
+  ** .pp
+  ** This specifies the folder into which read mail in your $$spoolfile
+  ** folder will be appended.
+  ** .pp
+  ** Also see the $$move variable.
+  */
+  { "mbox_type",	DT_MAGIC,R_NONE, UL &DefaultMagic, M_MBOX },
+  /*
+  ** .pp
+  ** The default mailbox type used when creating new folders. May be any of
+  ** ``mbox'', ``MMDF'', ``MH'' and ``Maildir''. This is overridden by the
+  ** \fC-m\fP command-line option.
+  */
+  { "menu_context",	DT_NUM,  R_NONE, UL &MenuContext, 0 },
+  /*
+  ** .pp
+  ** This variable controls the number of lines of context that are given
+  ** when scrolling through menus. (Similar to $$pager_context.)
+  */
+  { "menu_move_off",	DT_BOOL, R_NONE, OPTMENUMOVEOFF, 1 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, the bottom entry of menus will never scroll up past
+  ** the bottom of the screen, unless there are less entries than lines.
+  ** When \fIset\fP, the bottom entry may move off the bottom.
+  */
+  { "menu_scroll",	DT_BOOL, R_NONE, OPTMENUSCROLL, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, menus will be scrolled up or down one line when you
+  ** attempt to move across a screen boundary.  If \fIunset\fP, the screen
+  ** is cleared and the next or previous page of the menu is displayed
+  ** (useful for slow links to avoid many redraws).
+  */
+#if defined(USE_IMAP) || defined(USE_POP)
+  { "message_cache_clean", DT_BOOL, R_NONE, OPTMESSAGECACHECLEAN, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will clean out obsolete entries from the message cache when
+  ** the mailbox is synchronized. You probably only want to set it
+  ** every once in a while, since it can be a little slow
+  ** (especially for large folders).
+  */
+  { "message_cachedir",	DT_PATH,	R_NONE,	UL &MessageCachedir, 0 },
+  /*
+  ** .pp
+  ** Set this to a directory and mutt will cache copies of messages from
+  ** your IMAP and POP servers here. You are free to remove entries at any
+  ** time.
+  ** .pp
+  ** When setting this variable to a directory, mutt needs to fetch every
+  ** remote message only once and can perform regular expression searches
+  ** as fast as for local folders.
+  ** .pp
+  ** Also see the $$message_cache_clean variable.
+  */
+#endif
+  { "message_format",	DT_STR,	 R_NONE, UL &MsgFmt, UL "%s" },
+  /*
+  ** .pp
+  ** This is the string displayed in the ``attachment'' menu for
+  ** attachments of type \fCmessage/rfc822\fP.  For a full listing of defined
+  ** \fCprintf(3)\fP-like sequences see the section on $$index_format.
+  */
+  { "msg_format",	DT_SYN,  R_NONE, UL "message_format", 0 },
+  /*
+  */
+  { "meta_key",		DT_BOOL, R_NONE, OPTMETAKEY, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, forces Mutt to interpret keystrokes with the high bit (bit 8)
+  ** set as if the user had pressed the Esc key and whatever key remains
+  ** after having the high bit removed.  For example, if the key pressed
+  ** has an ASCII value of \fC0xf8\fP, then this is treated as if the user had
+  ** pressed Esc then ``x''.  This is because the result of removing the
+  ** high bit from \fC0xf8\fP is \fC0x78\fP, which is the ASCII character
+  ** ``x''.
+  */
+  { "metoo",		DT_BOOL, R_NONE, OPTMETOO, 0 },
+  /*
+  ** .pp
+  ** If \fIunset\fP, Mutt will remove your address (see the ``$alternates''
+  ** command) from the list of recipients when replying to a message.
+  */
+  { "mh_purge",		DT_BOOL, R_NONE, OPTMHPURGE, 0 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, mutt will mimic mh's behavior and rename deleted messages
+  ** to \fI,<old file name>\fP in mh folders instead of really deleting
+  ** them. This leaves the message on disk but makes programs reading the folder
+  ** ignore it. If the variable is \fIset\fP, the message files will simply be
+  ** deleted.
+  ** .pp
+  ** This option is similar to $$maildir_trash for Maildir folders.
+  */
+  { "mh_seq_flagged",	DT_STR, R_NONE, UL &MhFlagged, UL "flagged" },
+  /*
+  ** .pp
+  ** The name of the MH sequence used for flagged messages.
+  */
+  { "mh_seq_replied",	DT_STR, R_NONE, UL &MhReplied, UL "replied" },
+  /*
+  ** .pp
+  ** The name of the MH sequence used to tag replied messages.
+  */
+  { "mh_seq_unseen",	DT_STR, R_NONE, UL &MhUnseen, UL "unseen" },
+  /*
+  ** .pp
+  ** The name of the MH sequence used for unseen messages.
+  */
+  { "mime_forward",	DT_QUAD, R_NONE, OPT_MIMEFWD, M_NO },
+  /*
+  ** .pp
+  ** When \fIset\fP, the message you are forwarding will be attached as a
+  ** separate \fCmessage/rfc822\fP MIME part instead of included in the main body of the
+  ** message.  This is useful for forwarding MIME messages so the receiver
+  ** can properly view the message as it was delivered to you. If you like
+  ** to switch between MIME and not MIME from mail to mail, set this
+  ** variable to ``ask-no'' or ``ask-yes''.
+  ** .pp
+  ** Also see $$forward_decode and $$mime_forward_decode.
+  */
+  { "mime_forward_decode", DT_BOOL, R_NONE, OPTMIMEFORWDECODE, 0 },
+  /*
+  ** .pp
+  ** Controls the decoding of complex MIME messages into \fCtext/plain\fP when
+  ** forwarding a message while $$mime_forward is \fIset\fP. Otherwise
+  ** $$forward_decode is used instead.
+  */
+  { "mime_fwd",		DT_SYN,  R_NONE, UL "mime_forward", 0 },
+  /*
+  */
+  { "mime_forward_rest", DT_QUAD, R_NONE, OPT_MIMEFWDREST, M_YES },
+  /*
+  ** .pp
+  ** When forwarding multiple attachments of a MIME message from the attachment
+  ** menu, attachments which cannot be decoded in a reasonable manner will
+  ** be attached to the newly composed message if this option is \fIset\fP.
+  */
+#ifdef MIXMASTER
+  { "mix_entry_format", DT_STR,  R_NONE, UL &MixEntryFormat, UL "%4n %c %-16s %a" },
+  /*
+  ** .pp
+  ** This variable describes the format of a remailer line on the mixmaster
+  ** chain selection screen.  The following \fCprintf(3)\fP-like sequences are
+  ** supported:
+  ** .dl
+  ** .dt %n .dd The running number on the menu.
+  ** .dt %c .dd Remailer capabilities.
+  ** .dt %s .dd The remailer's short name.
+  ** .dt %a .dd The remailer's e-mail address.
+  ** .de
+  */
+  { "mixmaster",	DT_PATH, R_NONE, UL &Mixmaster, UL MIXMASTER },
+  /*
+  ** .pp
+  ** This variable contains the path to the Mixmaster binary on your
+  ** system.  It is used with various sets of parameters to gather the
+  ** list of known remailers, and to finally send a message through the
+  ** mixmaster chain.
+  */
+#endif
+  { "move",		DT_QUAD, R_NONE, OPT_MOVE, M_NO },
+  /*
+  ** .pp
+  ** Controls whether or not Mutt will move read messages
+  ** from your spool mailbox to your $$mbox mailbox, or as a result of
+  ** a ``$mbox-hook'' command.
+  */
+  { "narrow_tree",	DT_BOOL, R_TREE|R_INDEX, OPTNARROWTREE, 0 },
+  /*
+  ** .pp
+  ** This variable, when \fIset\fP, makes the thread tree narrower, allowing
+  ** deeper threads to fit on the screen.
+  */
+#ifdef USE_SOCKET
+  { "net_inc",	DT_NUM,	 R_NONE, UL &NetInc, 10 },
+  /*
+   ** .pp
+   ** Operations that expect to transfer a large amount of data over the
+   ** network will update their progress every $$net_inc kilobytes.
+   ** If set to 0, no progress messages will be displayed.
+   ** .pp
+   ** See also $$read_inc, $$write_inc and $$net_inc.
+   */
+#endif
+  { "pager",		DT_PATH, R_NONE, UL &Pager, UL "builtin" },
+  /*
+  ** .pp
+  ** This variable specifies which pager you would like to use to view
+  ** messages. The value ``builtin'' means to use the built-in pager, otherwise this
+  ** variable should specify the pathname of the external pager you would
+  ** like to use.
+  ** .pp
+  ** Using an external pager may have some disadvantages: Additional
+  ** keystrokes are necessary because you can't call mutt functions
+  ** directly from the pager, and screen resizes cause lines longer than
+  ** the screen width to be badly formatted in the help menu.
+  */
+  { "pager_context",	DT_NUM,	 R_NONE, UL &PagerContext, 0 },
+  /*
+  ** .pp
+  ** This variable controls the number of lines of context that are given
+  ** when displaying the next or previous page in the internal pager.  By
+  ** default, Mutt will display the line after the last one on the screen
+  ** at the top of the next page (0 lines of context).
+  ** .pp
+  ** This variable also specifies the amount of context given for search
+  ** results. If positive, this many lines will be given before a match,
+  ** if 0, the match will be top-aligned.
+  */
+  { "pager_format",	DT_STR,	 R_PAGER, UL &PagerFmt, UL "-%Z- %C/%m: %-20.20n   %s%*  -- (%P)" },
+  /*
+  ** .pp
+  ** This variable controls the format of the one-line message ``status''
+  ** displayed before each message in either the internal or an external
+  ** pager.  The valid sequences are listed in the $$index_format
+  ** section.
+  */
+  { "pager_index_lines",DT_NUM,	 R_PAGER, UL &PagerIndexLines, 0 },
+  /*
+  ** .pp
+  ** Determines the number of lines of a mini-index which is shown when in
+  ** the pager.  The current message, unless near the top or bottom of the
+  ** folder, will be roughly one third of the way down this mini-index,
+  ** giving the reader the context of a few messages before and after the
+  ** message.  This is useful, for example, to determine how many messages
+  ** remain to be read in the current thread.  One of the lines is reserved
+  ** for the status bar from the index, so a setting of 6
+  ** will only show 5 lines of the actual index.  A value of 0 results in
+  ** no index being shown.  If the number of messages in the current folder
+  ** is less than $$pager_index_lines, then the index will only use as
+  ** many lines as it needs.
+  */
+  { "pager_stop",	DT_BOOL, R_NONE, OPTPAGERSTOP, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, the internal-pager will \fBnot\fP move to the next message
+  ** when you are at the end of a message and invoke the \fC<next-page>\fP
+  ** function.
+  */
+  { "pgp_auto_decode", DT_BOOL, R_NONE, OPTPGPAUTODEC, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will automatically attempt to decrypt traditional PGP
+  ** messages whenever the user performs an operation which ordinarily would
+  ** result in the contents of the message being operated on.  For example,
+  ** if the user displays a pgp-traditional message which has not been manually
+  ** checked with the \fC$<check-traditional-pgp>\fP function, mutt will automatically
+  ** check the message for traditional pgp.
+  */
+  { "pgp_create_traditional",	DT_SYN, R_NONE, UL "pgp_autoinline", 0 },
+  { "pgp_autoinline",		DT_BOOL, R_NONE, OPTPGPAUTOINLINE, 0 },
+  /*
+  ** .pp
+  ** This option controls whether Mutt generates old-style inline
+  ** (traditional) PGP encrypted or signed messages under certain
+  ** circumstances.  This can be overridden by use of the pgp menu,
+  ** when inline is not required.
+  ** .pp
+  ** Note that Mutt might automatically use PGP/MIME for messages
+  ** which consist of more than a single MIME part.  Mutt can be
+  ** configured to ask before sending PGP/MIME messages when inline
+  ** (traditional) would not work.
+  ** .pp
+  ** Also see the $$pgp_mime_auto variable.
+  ** .pp
+  ** Also note that using the old-style PGP message format is \fBstrongly\fP
+  ** \fBdeprecated\fP.
+  ** (PGP only)
+  */
+  { "pgp_check_exit",	DT_BOOL, R_NONE, OPTPGPCHECKEXIT, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will check the exit code of the PGP subprocess when
+  ** signing or encrypting.  A non-zero exit code means that the
+  ** subprocess failed.
+  ** (PGP only)
+  */
+  { "pgp_clearsign_command",	DT_STR,	R_NONE, UL &PgpClearSignCommand, 0 },
+  /*
+  ** .pp
+  ** This format is used to create an old-style ``clearsigned'' PGP
+  ** message.  Note that the use of this format is \fBstrongly\fP
+  ** \fBdeprecated\fP.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_decode_command",       DT_STR, R_NONE, UL &PgpDecodeCommand, 0},
+  /*
+  ** .pp
+  ** This format strings specifies a command which is used to decode
+  ** application/pgp attachments.
+  ** .pp
+  ** The PGP command formats have their own set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %p .dd Expands to PGPPASSFD=0 when a pass phrase is needed, to an empty
+  **            string otherwise. Note: This may be used with a %? construct.
+  ** .dt %f .dd Expands to the name of a file containing a message.
+  ** .dt %s .dd Expands to the name of a file containing the signature part
+  ** .          of a \fCmultipart/signed\fP attachment when verifying it.
+  ** .dt %a .dd The value of $$pgp_sign_as.
+  ** .dt %r .dd One or more key IDs (or fingerprints if available).
+  ** .de
+  ** .pp
+  ** For examples on how to configure these formats for the various versions
+  ** of PGP which are floating around, see the pgp and gpg sample configuration files in
+  ** the \fCsamples/\fP subdirectory which has been installed on your system
+  ** alongside the documentation.
+  ** (PGP only)
+  */
+  { "pgp_decrypt_command", 	DT_STR, R_NONE, UL &PgpDecryptCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to decrypt a PGP encrypted message.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_encrypt_only_command", DT_STR, R_NONE, UL &PgpEncryptOnlyCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to encrypt a body part without signing it.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_encrypt_sign_command",	DT_STR, R_NONE, UL &PgpEncryptSignCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to both sign and encrypt a body part.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_entry_format", DT_STR,  R_NONE, UL &PgpEntryFormat, UL "%4n %t%f %4l/0x%k %-4a %2c %u" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the PGP key selection menu to
+  ** your personal taste. This string is similar to $$index_format, but
+  ** has its own set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %n     .dd number
+  ** .dt %k     .dd key id
+  ** .dt %u     .dd user id
+  ** .dt %a     .dd algorithm
+  ** .dt %l     .dd key length
+  ** .dt %f     .dd flags
+  ** .dt %c     .dd capabilities
+  ** .dt %t     .dd trust/validity of the key-uid association
+  ** .dt %[<s>] .dd date of the key where <s> is an \fCstrftime(3)\fP expression
+  ** .de
+  ** .pp
+  ** (PGP only)
+  */
+  { "pgp_export_command", 	DT_STR, R_NONE, UL &PgpExportCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to export a public key from the user's
+  ** key ring.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_getkeys_command",	DT_STR, R_NONE, UL &PgpGetkeysCommand, 0},
+  /*
+  ** .pp
+  ** This command is invoked whenever Mutt needs to fetch the public key associated with
+  ** an email address.  Of the sequences supported by $$pgp_decode_command, %r is
+  ** the only \fCprintf(3)\fP-like sequence used with this format.  Note that
+  ** in this case, %r expands to the email address, not the public key ID (the key ID is
+  ** unknown, which is why Mutt is invoking this command).
+  ** (PGP only)
+  */
+  { "pgp_good_sign",	DT_RX,  R_NONE, UL &PgpGoodSign, 0 },
+  /*
+  ** .pp
+  ** If you assign a text to this variable, then a PGP signature is only
+  ** considered verified if the output from $$pgp_verify_command contains
+  ** the text. Use this variable if the exit code from the command is 0
+  ** even for bad signatures.
+  ** (PGP only)
+  */
+  { "pgp_ignore_subkeys", DT_BOOL, R_NONE, OPTPGPIGNORESUB, 1},
+  /*
+  ** .pp
+  ** Setting this variable will cause Mutt to ignore OpenPGP subkeys. Instead,
+  ** the principal key will inherit the subkeys' capabilities.  \fIUnset\fP this
+  ** if you want to play interesting key selection games.
+  ** (PGP only)
+  */
+  { "pgp_import_command",	DT_STR, R_NONE, UL &PgpImportCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to import a key from a message into
+  ** the user's public key ring.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_list_pubring_command", DT_STR, R_NONE, UL &PgpListPubringCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to list the public key ring's contents.  The
+  ** output format must be analogous to the one used by
+  ** .ts
+  ** gpg --list-keys --with-colons --with-fingerprint
+  ** .te
+  ** .pp
+  ** This format is also generated by the \fCpgpring\fP utility which comes
+  ** with mutt.
+  ** .pp
+  ** Note: gpg's \fCfixed-list-mode\fP option should not be used.  It
+  ** produces a different date format which may result in mutt showing
+  ** incorrect key generation dates.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_list_secring_command",	DT_STR, R_NONE, UL &PgpListSecringCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to list the secret key ring's contents.  The
+  ** output format must be analogous to the one used by:
+  ** .ts
+  ** gpg --list-keys --with-colons --with-fingerprint
+  ** .te
+  ** .pp
+  ** This format is also generated by the \fCpgpring\fP utility which comes
+  ** with mutt.
+  ** .pp
+  ** Note: gpg's \fCfixed-list-mode\fP option should not be used.  It
+  ** produces a different date format which may result in mutt showing
+  ** incorrect key generation dates.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_long_ids",	DT_BOOL, R_NONE, OPTPGPLONGIDS, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, use 64 bit PGP key IDs, if \fIunset\fP use the normal 32 bit key IDs.
+  ** NOTE: Internally, Mutt has transitioned to using fingerprints (or long key IDs
+  ** as a fallback).  This option now only controls the display of key IDs
+  ** in the key selection menu and a few other places.
+  ** (PGP only)
+  */
+  { "pgp_mime_auto", DT_QUAD, R_NONE, OPT_PGPMIMEAUTO, M_ASKYES },
+  /*
+  ** .pp
+  ** This option controls whether Mutt will prompt you for
+  ** automatically sending a (signed/encrypted) message using
+  ** PGP/MIME when inline (traditional) fails (for any reason).
+  ** .pp
+  ** Also note that using the old-style PGP message format is \fBstrongly\fP
+  ** \fBdeprecated\fP.
+  ** (PGP only)
+  */
+  { "pgp_auto_traditional",	DT_SYN, R_NONE, UL "pgp_replyinline", 0 },
+  { "pgp_replyinline",		DT_BOOL, R_NONE, OPTPGPREPLYINLINE, 0 },
+  /*
+  ** .pp
+  ** Setting this variable will cause Mutt to always attempt to
+  ** create an inline (traditional) message when replying to a
+  ** message which is PGP encrypted/signed inline.  This can be
+  ** overridden by use of the pgp menu, when inline is not
+  ** required.  This option does not automatically detect if the
+  ** (replied-to) message is inline; instead it relies on Mutt
+  ** internals for previously checked/flagged messages.
+  ** .pp
+  ** Note that Mutt might automatically use PGP/MIME for messages
+  ** which consist of more than a single MIME part.  Mutt can be
+  ** configured to ask before sending PGP/MIME messages when inline
+  ** (traditional) would not work.
+  ** .pp
+  ** Also see the $$pgp_mime_auto variable.
+  ** .pp
+  ** Also note that using the old-style PGP message format is \fBstrongly\fP
+  ** \fBdeprecated\fP.
+  ** (PGP only)
+  **
+  */
+  { "pgp_retainable_sigs", DT_BOOL, R_NONE, OPTPGPRETAINABLESIG, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, signed and encrypted messages will consist of nested
+  ** \fCmultipart/signed\fP and \fCmultipart/encrypted\fP body parts.
+  ** .pp
+  ** This is useful for applications like encrypted and signed mailing
+  ** lists, where the outer layer (\fCmultipart/encrypted\fP) can be easily
+  ** removed, while the inner \fCmultipart/signed\fP part is retained.
+  ** (PGP only)
+  */
+  { "pgp_show_unusable", DT_BOOL, R_NONE, OPTPGPSHOWUNUSABLE, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will display non-usable keys on the PGP key selection
+  ** menu.  This includes keys which have been revoked, have expired, or
+  ** have been marked as ``disabled'' by the user.
+  ** (PGP only)
+  */
+  { "pgp_sign_as",	DT_STR,	 R_NONE, UL &PgpSignAs, 0 },
+  /*
+  ** .pp
+  ** If you have more than one key pair, this option allows you to specify
+  ** which of your private keys to use.  It is recommended that you use the
+  ** keyid form to specify your key (e.g. \fC0x00112233\fP).
+  ** (PGP only)
+  */
+  { "pgp_sign_command",		DT_STR, R_NONE, UL &PgpSignCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to create the detached PGP signature for a
+  ** \fCmultipart/signed\fP PGP/MIME body part.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_sort_keys",	DT_SORT|DT_SORT_KEYS, R_NONE, UL &PgpSortKeys, SORT_ADDRESS },
+  /*
+  ** .pp
+  ** Specifies how the entries in the pgp menu are sorted. The
+  ** following are legal values:
+  ** .dl
+  ** .dt address .dd sort alphabetically by user id
+  ** .dt keyid   .dd sort alphabetically by key id
+  ** .dt date    .dd sort by key creation date
+  ** .dt trust   .dd sort by the trust of the key
+  ** .de
+  ** .pp
+  ** If you prefer reverse order of the above values, prefix it with
+  ** ``reverse-''.
+  ** (PGP only)
+  */
+  { "pgp_strict_enc",	DT_BOOL, R_NONE, OPTPGPSTRICTENC, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will automatically encode PGP/MIME signed messages as
+  ** quoted-printable.  Please note that unsetting this variable may
+  ** lead to problems with non-verifyable PGP signatures, so only change
+  ** this if you know what you are doing.
+  ** (PGP only)
+  */
+  { "pgp_timeout",	DT_NUM,	 R_NONE, UL &PgpTimeout, 300 },
+  /*
+  ** .pp
+  ** The number of seconds after which a cached passphrase will expire if
+  ** not used.
+  ** (PGP only)
+  */
+  { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will use a possibly-running \fCgpg-agent(1)\fP process.
+  ** Note that as of version 2.1, GnuPG no longer exports GPG_AGENT_INFO, so
+  ** mutt no longer verifies if the agent is running.
+  ** (PGP only)
+  */
+  { "pgp_verify_command", 	DT_STR, R_NONE, UL &PgpVerifyCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to verify PGP signatures.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pgp_verify_key_command",	DT_STR, R_NONE, UL &PgpVerifyKeyCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to verify key information from the key selection
+  ** menu.
+  ** .pp
+  ** This is a format string, see the $$pgp_decode_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (PGP only)
+  */
+  { "pipe_decode",	DT_BOOL, R_NONE, OPTPIPEDECODE, 0 },
+  /*
+  ** .pp
+  ** Used in connection with the \fC<pipe-message>\fP command.  When \fIunset\fP,
+  ** Mutt will pipe the messages without any preprocessing. When \fIset\fP, Mutt
+  ** will weed headers and will attempt to decode the messages
+  ** first.
+  */
+  { "pipe_sep",		DT_STR,	 R_NONE, UL &PipeSep, UL "\n" },
+  /*
+  ** .pp
+  ** The separator to add between messages when piping a list of tagged
+  ** messages to an external Unix command.
+  */
+  { "pipe_split",	DT_BOOL, R_NONE, OPTPIPESPLIT, 0 },
+  /*
+  ** .pp
+  ** Used in connection with the \fC<pipe-message>\fP function following
+  ** \fC<tag-prefix>\fP.  If this variable is \fIunset\fP, when piping a list of
+  ** tagged messages Mutt will concatenate the messages and will pipe them
+  ** all concatenated.  When \fIset\fP, Mutt will pipe the messages one by one.
+  ** In both cases the messages are piped in the current sorted order,
+  ** and the $$pipe_sep separator is added after each message.
+  */
+#ifdef USE_POP
+  { "pop_auth_try_all",	DT_BOOL, R_NONE, OPTPOPAUTHTRYALL, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will try all available authentication methods.
+  ** When \fIunset\fP, Mutt will only fall back to other authentication
+  ** methods if the previous methods are unavailable. If a method is
+  ** available but authentication fails, Mutt will not connect to the POP server.
+  */
+  { "pop_authenticators", DT_STR, R_NONE, UL &PopAuthenticators, UL 0 },
+  /*
+  ** .pp
+  ** This is a colon-delimited list of authentication methods mutt may
+  ** attempt to use to log in to an POP server, in the order mutt should
+  ** try them.  Authentication methods are either ``user'', ``apop'' or any
+  ** SASL mechanism, e.g. ``digest-md5'', ``gssapi'' or ``cram-md5''.
+  ** This option is case-insensitive. If this option is \fIunset\fP
+  ** (the default) mutt will try all available methods, in order from
+  ** most-secure to least-secure.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set pop_authenticators="digest-md5:apop:user"
+  ** .te
+  */
+  { "pop_checkinterval", DT_NUM, R_NONE, UL &PopCheckTimeout, 60 },
+  /*
+  ** .pp
+  ** This variable configures how often (in seconds) mutt should look for
+  ** new mail in the currently selected mailbox if it is a POP mailbox.
+  */
+  { "pop_delete",	DT_QUAD, R_NONE, OPT_POPDELETE, M_ASKNO },
+  /*
+  ** .pp
+  ** If \fIset\fP, Mutt will delete successfully downloaded messages from the POP
+  ** server when using the \fC$<fetch-mail>\fP function.  When \fIunset\fP, Mutt will
+  ** download messages but also leave them on the POP server.
+  */
+  { "pop_host",		DT_STR,	 R_NONE, UL &PopHost, UL "" },
+  /*
+  ** .pp
+  ** The name of your POP server for the \fC$<fetch-mail>\fP function.  You
+  ** can also specify an alternative port, username and password, i.e.:
+  ** .ts
+  ** [pop[s]://][username[:password]@]popserver[:port]
+  ** .te
+  ** .pp
+  ** where ``[...]'' denotes an optional part.
+  */
+  { "pop_last",		DT_BOOL, R_NONE, OPTPOPLAST, 0 },
+  /*
+  ** .pp
+  ** If this variable is \fIset\fP, mutt will try to use the ``\fCLAST\fP'' POP command
+  ** for retrieving only unread messages from the POP server when using
+  ** the \fC$<fetch-mail>\fP function.
+  */
+  { "pop_pass",		DT_STR,	 R_NONE, UL &PopPass, UL "" },
+  /*
+  ** .pp
+  ** Specifies the password for your POP account.  If \fIunset\fP, Mutt will
+  ** prompt you for your password when you open a POP mailbox.
+  ** .pp
+  ** \fBWarning\fP: you should only use this option when you are on a
+  ** fairly secure machine, because the superuser can read your muttrc
+  ** even if you are the only one who can read the file.
+  */
+  { "pop_reconnect",	DT_QUAD, R_NONE, OPT_POPRECONNECT, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not Mutt will try to reconnect to the POP server if
+  ** the connection is lost.
+  */
+  { "pop_user",		DT_STR,	 R_NONE, UL &PopUser, 0 },
+  /*
+  ** .pp
+  ** Your login name on the POP server.
+  ** .pp
+  ** This variable defaults to your user name on the local machine.
+  */
+#endif /* USE_POP */
+  { "post_indent_string",DT_STR, R_NONE, UL &PostIndentString, UL "" },
+  /*
+  ** .pp
+  ** Similar to the $$attribution variable, Mutt will append this
+  ** string after the inclusion of a message which is being replied to.
+  */
+  { "post_indent_str",  DT_SYN,  R_NONE, UL "post_indent_string", 0 },
+  /*
+  */
+  { "postpone",		DT_QUAD, R_NONE, OPT_POSTPONE, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not messages are saved in the $$postponed
+  ** mailbox when you elect not to send immediately.
+  ** .pp
+  ** Also see the $$recall variable.
+  */
+  { "postponed",	DT_PATH, R_INDEX, UL &Postponed, UL "~/postponed" },
+  /*
+  ** .pp
+  ** Mutt allows you to indefinitely ``$postpone sending a message'' which
+  ** you are editing.  When you choose to postpone a message, Mutt saves it
+  ** in the mailbox specified by this variable.
+  ** .pp
+  ** Also see the $$postpone variable.
+  */
+  { "postpone_encrypt",    DT_BOOL, R_NONE, OPTPOSTPONEENCRYPT, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, postponed messages that are marked for encryption will be
+  ** encrypted using the key in $$postpone_encrypt_as before saving.
+  ** (Crypto only)
+  */
+  { "postpone_encrypt_as", DT_STR,  R_NONE, UL &PostponeEncryptAs, 0 },
+  /*
+  ** .pp
+  ** This is the key used to encrypt postponed messages.  It should be in
+  ** keyid or fingerprint form (e.g. 0x00112233 for PGP or the
+  ** hash-value that OpenSSL generates for S/MIME).
+  ** (Crypto only)
+  */
+#ifdef USE_SOCKET
+  { "preconnect",	DT_STR, R_NONE, UL &Preconnect, UL 0},
+  /*
+  ** .pp
+  ** If \fIset\fP, a shell command to be executed if mutt fails to establish
+  ** a connection to the server. This is useful for setting up secure
+  ** connections, e.g. with \fCssh(1)\fP. If the command returns a  nonzero
+  ** status, mutt gives up opening the server. Example:
+  ** .ts
+  ** set preconnect="ssh -f -q -L 1234:mailhost.net:143 mailhost.net \(rs
+  ** sleep 20 < /dev/null > /dev/null"
+  ** .te
+  ** .pp
+  ** Mailbox ``foo'' on ``mailhost.net'' can now be reached
+  ** as ``{localhost:1234}foo''.
+  ** .pp
+  ** Note: For this example to work, you must be able to log in to the
+  ** remote machine without having to enter a password.
+  */
+#endif /* USE_SOCKET */
+  { "print",		DT_QUAD, R_NONE, OPT_PRINT, M_ASKNO },
+  /*
+  ** .pp
+  ** Controls whether or not Mutt really prints messages.
+  ** This is set to ``ask-no'' by default, because some people
+  ** accidentally hit ``p'' often.
+  */
+  { "print_command",	DT_PATH, R_NONE, UL &PrintCmd, UL "lpr" },
+  /*
+  ** .pp
+  ** This specifies the command pipe that should be used to print messages.
+  */
+  { "print_cmd",	DT_SYN,  R_NONE, UL "print_command", 0 },
+  /*
+  */
+  { "print_decode",	DT_BOOL, R_NONE, OPTPRINTDECODE, 1 },
+  /*
+  ** .pp
+  ** Used in connection with the \fC<print-message>\fP command.  If this
+  ** option is \fIset\fP, the message is decoded before it is passed to the
+  ** external command specified by $$print_command.  If this option
+  ** is \fIunset\fP, no processing will be applied to the message when
+  ** printing it.  The latter setting may be useful if you are using
+  ** some advanced printer filter which is able to properly format
+  ** e-mail messages for printing.
+  */
+  { "print_split",	DT_BOOL, R_NONE, OPTPRINTSPLIT,  0 },
+  /*
+  ** .pp
+  ** Used in connection with the \fC<print-message>\fP command.  If this option
+  ** is \fIset\fP, the command specified by $$print_command is executed once for
+  ** each message which is to be printed.  If this option is \fIunset\fP,
+  ** the command specified by $$print_command is executed only once, and
+  ** all the messages are concatenated, with a form feed as the message
+  ** separator.
+  ** .pp
+  ** Those who use the \fCenscript\fP(1) program's mail-printing mode will
+  ** most likely want to \fIset\fP this option.
+  */
+  { "prompt_after",	DT_BOOL, R_NONE, OPTPROMPTAFTER, 1 },
+  /*
+  ** .pp
+  ** If you use an \fIexternal\fP $$pager, setting this variable will
+  ** cause Mutt to prompt you for a command when the pager exits rather
+  ** than returning to the index menu.  If \fIunset\fP, Mutt will return to the
+  ** index menu when the external pager exits.
+  */
+  { "query_command",	DT_PATH, R_NONE, UL &QueryCmd, UL "" },
+  /*
+  ** .pp
+  ** This specifies the command Mutt will use to make external address
+  ** queries.  The string may contain a ``%s'', which will be substituted
+  ** with the query string the user types.  Mutt will add quotes around the
+  ** string substituted for ``%s'' automatically according to shell quoting
+  ** rules, so you should avoid adding your own.  If no ``%s'' is found in
+  ** the string, Mutt will append the user's query to the end of the string.
+  ** See ``$query'' for more information.
+  */
+  { "query_format",	DT_STR, R_NONE, UL &QueryFormat, UL "%4c %t %-25.25a %-25.25n %?e?(%e)?" },
+  /*
+  ** .pp
+  ** This variable describes the format of the ``query'' menu. The
+  ** following \fCprintf(3)\fP-style sequences are understood:
+  ** .dl
+  ** .dt %a  .dd destination address
+  ** .dt %c  .dd current entry number
+  ** .dt %e  .dd extra information *
+  ** .dt %n  .dd destination name
+  ** .dt %t  .dd ``*'' if current entry is tagged, a space otherwise
+  ** .dt %>X .dd right justify the rest of the string and pad with ``X''
+  ** .dt %|X .dd pad to the end of the line with ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  ** .pp
+  ** * = can be optionally printed if nonzero, see the $$status_format documentation.
+  */
+  { "quit",		DT_QUAD, R_NONE, OPT_QUIT, M_YES },
+  /*
+  ** .pp
+  ** This variable controls whether ``quit'' and ``exit'' actually quit
+  ** from mutt.  If this option is \fIset\fP, they do quit, if it is \fIunset\fP, they
+  ** have no effect, and if it is set to \fIask-yes\fP or \fIask-no\fP, you are
+  ** prompted for confirmation when you try to quit.
+  */
+  { "quote_regexp",	DT_RX,	 R_PAGER, UL &QuoteRegexp, UL "^([ \t]*[|>:}#])+" },
+  /*
+  ** .pp
+  ** A regular expression used in the internal pager to determine quoted
+  ** sections of text in the body of a message. Quoted text may be filtered
+  ** out using the \fC<toggle-quoted>\fP command, or colored according to the
+  ** ``color quoted'' family of directives.
+  ** .pp
+  ** Higher levels of quoting may be colored differently (``color quoted1'',
+  ** ``color quoted2'', etc.). The quoting level is determined by removing
+  ** the last character from the matched text and recursively reapplying
+  ** the regular expression until it fails to produce a match.
+  ** .pp
+  ** Match detection may be overridden by the $$smileys regular expression.
+  */
+  { "read_inc",		DT_NUM,	 R_NONE, UL &ReadInc, 10 },
+  /*
+  ** .pp
+  ** If set to a value greater than 0, Mutt will display which message it
+  ** is currently on when reading a mailbox or when performing search actions
+  ** such as search and limit. The message is printed after
+  ** this many messages have been read or searched (e.g., if set to 25, Mutt will
+  ** print a message when it is at message 25, and then again when it gets
+  ** to message 50).  This variable is meant to indicate progress when
+  ** reading or searching large mailboxes which may take some time.
+  ** When set to 0, only a single message will appear before the reading
+  ** the mailbox.
+  ** .pp
+  ** Also see the $$write_inc, $$net_inc and $$time_inc variables and the
+  ** ``$tuning'' section of the manual for performance considerations.
+  */
+  { "read_only",	DT_BOOL, R_NONE, OPTREADONLY, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, all folders are opened in read-only mode.
+  */
+  { "realname",		DT_STR,	 R_BOTH, UL &Realname, 0 },
+  /*
+  ** .pp
+  ** This variable specifies what ``real'' or ``personal'' name should be used
+  ** when sending messages.
+  ** .pp
+  ** By default, this is the GECOS field from \fC/etc/passwd\fP.  Note that this
+  ** variable will \fInot\fP be used when the user has set a real name
+  ** in the $$from variable.
+  */
+  { "recall",		DT_QUAD, R_NONE, OPT_RECALL, M_ASKYES },
+  /*
+  ** .pp
+  ** Controls whether or not Mutt recalls postponed messages
+  ** when composing a new message.
+  ** .pp
+  ** \fISetting\fP this variable to is not generally useful, and thus not
+  ** recommended.
+  ** .pp
+  ** Also see $$postponed variable.
+  */
+  { "record",		DT_PATH, R_NONE, UL &Outbox, UL "~/sent" },
+  /*
+  ** .pp
+  ** This specifies the file into which your outgoing messages should be
+  ** appended.  (This is meant as the primary method for saving a copy of
+  ** your messages, but another way to do this is using the ``$my_hdr''
+  ** command to create a ``Bcc:'' field with your email address in it.)
+  ** .pp
+  ** The value of \fI$$record\fP is overridden by the $$force_name and
+  ** $$save_name variables, and the ``$fcc-hook'' command.
+  */
+  { "reflow_text",	DT_BOOL, R_NONE, OPTREFLOWTEXT, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will reformat paragraphs in text/plain
+  ** parts marked format=flowed.  If \fIunset\fP, Mutt will display paragraphs
+  ** unaltered from how they appear in the message body.  See RFC3676 for
+  ** details on the \fIformat=flowed\fP format.
+  ** .pp
+  ** Also see $$reflow_wrap, and $$wrap.
+  */
+  { "reflow_wrap",	DT_NUM,	R_NONE, UL &ReflowWrap, 78 },
+  /*
+  ** .pp
+  ** This variable controls the maximum paragraph width when reformatting text/plain
+  ** parts when $$reflow_text is \fIset\fP.  When the value is 0, paragraphs will
+  ** be wrapped at the terminal's right margin.  A positive value sets the
+  ** paragraph width relative to the left margin.  A negative value set the
+  ** paragraph width relative to the right margin.
+  ** .pp
+  ** Also see $$wrap.
+  */
+  { "reply_regexp",	DT_RX,	 R_INDEX|R_RESORT, UL &ReplyRegexp, UL "^(re([\\[0-9\\]+])*|aw):[ \t]*" },
+  /*
+  ** .pp
+  ** A regular expression used to recognize reply messages when threading
+  ** and replying. The default value corresponds to the English "Re:" and
+  ** the German "Aw:".
+  */
+  { "reply_self",	DT_BOOL, R_NONE, OPTREPLYSELF, 0 },
+  /*
+  ** .pp
+  ** If \fIunset\fP and you are replying to a message sent by you, Mutt will
+  ** assume that you want to reply to the recipients of that message rather
+  ** than to yourself.
+  ** .pp
+  ** Also see the ``$alternates'' command.
+  */
+  { "reply_to",		DT_QUAD, R_NONE, OPT_REPLYTO, M_ASKYES },
+  /*
+  ** .pp
+  ** If \fIset\fP, when replying to a message, Mutt will use the address listed
+  ** in the Reply-to: header as the recipient of the reply.  If \fIunset\fP,
+  ** it will use the address in the From: header field instead.  This
+  ** option is useful for reading a mailing list that sets the Reply-To:
+  ** header field to the list address and you want to send a private
+  ** message to the author of a message.
+  */
+  { "resolve",		DT_BOOL, R_NONE, OPTRESOLVE, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, the cursor will be automatically advanced to the next
+  ** (possibly undeleted) message whenever a command that modifies the
+  ** current message is executed.
+  */
+  { "reverse_alias",	DT_BOOL, R_BOTH, OPTREVALIAS, 0 },
+  /*
+  ** .pp
+  ** This variable controls whether or not Mutt will display the ``personal''
+  ** name from your aliases in the index menu if it finds an alias that
+  ** matches the message's sender.  For example, if you have the following
+  ** alias:
+  ** .ts
+  ** alias juser abd30425@somewhere.net (Joe User)
+  ** .te
+  ** .pp
+  ** and then you receive mail which contains the following header:
+  ** .ts
+  ** From: abd30425@somewhere.net
+  ** .te
+  ** .pp
+  ** It would be displayed in the index menu as ``Joe User'' instead of
+  ** ``abd30425@somewhere.net.''  This is useful when the person's e-mail
+  ** address is not human friendly.
+  */
+  { "reverse_name",	DT_BOOL, R_BOTH, OPTREVNAME, 0 },
+  /*
+  ** .pp
+  ** It may sometimes arrive that you receive mail to a certain machine,
+  ** move the messages to another machine, and reply to some the messages
+  ** from there.  If this variable is \fIset\fP, the default \fIFrom:\fP line of
+  ** the reply messages is built using the address where you received the
+  ** messages you are replying to \fBif\fP that address matches your
+  ** ``$alternates''.  If the variable is \fIunset\fP, or the address that would be
+  ** used doesn't match your ``$alternates'', the \fIFrom:\fP line will use
+  ** your address on the current machine.
+  ** .pp
+  ** Also see the ``$alternates'' command.
+  */
+  { "reverse_realname",	DT_BOOL, R_BOTH, OPTREVREAL, 1 },
+  /*
+  ** .pp
+  ** This variable fine-tunes the behavior of the $$reverse_name feature.
+  ** When it is \fIset\fP, mutt will use the address from incoming messages as-is,
+  ** possibly including eventual real names.  When it is \fIunset\fP, mutt will
+  ** override any such real names with the setting of the $$realname variable.
+  */
+  { "rfc2047_parameters", DT_BOOL, R_NONE, OPTRFC2047PARAMS, 0 },
+  /*
+  ** .pp
+  ** When this variable is \fIset\fP, Mutt will decode RFC2047-encoded MIME
+  ** parameters. You want to set this variable when mutt suggests you
+  ** to save attachments to files named like:
+  ** .ts
+  ** =?iso-8859-1?Q?file=5F=E4=5F991116=2Ezip?=
+  ** .te
+  ** .pp
+  ** When this variable is \fIset\fP interactively, the change won't be
+  ** active until you change folders.
+  ** .pp
+  ** Note that this use of RFC2047's encoding is explicitly
+  ** prohibited by the standard, but nevertheless encountered in the
+  ** wild.
+  ** .pp
+  ** Also note that setting this parameter will \fInot\fP have the effect
+  ** that mutt \fIgenerates\fP this kind of encoding.  Instead, mutt will
+  ** unconditionally use the encoding specified in RFC2231.
+  */
+  { "save_address",	DT_BOOL, R_NONE, OPTSAVEADDRESS, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, mutt will take the sender's full address when choosing a
+  ** default folder for saving a mail. If $$save_name or $$force_name
+  ** is \fIset\fP too, the selection of the Fcc folder will be changed as well.
+  */
+  { "save_empty",	DT_BOOL, R_NONE, OPTSAVEEMPTY, 1 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, mailboxes which contain no saved messages will be removed
+  ** when closed (the exception is $$spoolfile which is never removed).
+  ** If \fIset\fP, mailboxes are never removed.
+  ** .pp
+  ** \fBNote:\fP This only applies to mbox and MMDF folders, Mutt does not
+  ** delete MH and Maildir directories.
+  */
+  { "save_history",     DT_NUM,  R_NONE, UL &SaveHist, 0 },
+  /*
+  ** .pp
+  ** This variable controls the size of the history (per category) saved in the
+  ** $$history_file file.
+  */
+  { "save_name",	DT_BOOL, R_NONE, OPTSAVENAME, 0 },
+  /*
+  ** .pp
+  ** This variable controls how copies of outgoing messages are saved.
+  ** When \fIset\fP, a check is made to see if a mailbox specified by the
+  ** recipient address exists (this is done by searching for a mailbox in
+  ** the $$folder directory with the \fIusername\fP part of the
+  ** recipient address).  If the mailbox exists, the outgoing message will
+  ** be saved to that mailbox, otherwise the message is saved to the
+  ** $$record mailbox.
+  ** .pp
+  ** Also see the $$force_name variable.
+  */
+  { "score", 		DT_BOOL, R_NONE, OPTSCORE, 1 },
+  /*
+  ** .pp
+  ** When this variable is \fIunset\fP, scoring is turned off.  This can
+  ** be useful to selectively disable scoring for certain folders when the
+  ** $$score_threshold_delete variable and related are used.
+  **
+  */
+  { "score_threshold_delete", DT_NUM, R_NONE, UL &ScoreThresholdDelete, UL -1 },
+  /*
+  ** .pp
+  ** Messages which have been assigned a score equal to or lower than the value
+  ** of this variable are automatically marked for deletion by mutt.  Since
+  ** mutt scores are always greater than or equal to zero, the default setting
+  ** of this variable will never mark a message for deletion.
+  */
+  { "score_threshold_flag", DT_NUM, R_NONE, UL &ScoreThresholdFlag, 9999 },
+  /*
+  ** .pp
+  ** Messages which have been assigned a score greater than or equal to this
+  ** variable's value are automatically marked "flagged".
+  */
+  { "score_threshold_read", DT_NUM, R_NONE, UL &ScoreThresholdRead, UL -1 },
+  /*
+  ** .pp
+  ** Messages which have been assigned a score equal to or lower than the value
+  ** of this variable are automatically marked as read by mutt.  Since
+  ** mutt scores are always greater than or equal to zero, the default setting
+  ** of this variable will never mark a message read.
+  */
+  { "search_context",	DT_NUM,  R_NONE, UL &SearchContext, UL 0 },
+  /*
+  ** .pp
+  ** For the pager, this variable specifies the number of lines shown
+  ** before search results. By default, search results will be top-aligned.
+  */
+  { "send_charset",	DT_STR,  R_NONE, UL &SendCharset, UL "us-ascii:iso-8859-1:utf-8" },
+  /*
+  ** .pp
+  ** A colon-delimited list of character sets for outgoing messages. Mutt will use the
+  ** first character set into which the text can be converted exactly.
+  ** If your $$charset is not ``iso-8859-1'' and recipients may not
+  ** understand ``UTF-8'', it is advisable to include in the list an
+  ** appropriate widely used standard character set (such as
+  ** ``iso-8859-2'', ``koi8-r'' or ``iso-2022-jp'') either instead of or after
+  ** ``iso-8859-1''.
+  ** .pp
+  ** In case the text cannot be converted into one of these exactly,
+  ** mutt uses $$charset as a fallback.
+  */
+  { "sendmail",		DT_PATH, R_NONE, UL &Sendmail, UL SENDMAIL " -oem -oi" },
+  /*
+  ** .pp
+  ** Specifies the program and arguments used to deliver mail sent by Mutt.
+  ** Mutt expects that the specified program interprets additional
+  ** arguments as recipient addresses.
+  */
+  { "sendmail_wait",	DT_NUM,  R_NONE, UL &SendmailWait, 0 },
+  /*
+  ** .pp
+  ** Specifies the number of seconds to wait for the $$sendmail process
+  ** to finish before giving up and putting delivery in the background.
+  ** .pp
+  ** Mutt interprets the value of this variable as follows:
+  ** .dl
+  ** .dt >0 .dd number of seconds to wait for sendmail to finish before continuing
+  ** .dt 0  .dd wait forever for sendmail to finish
+  ** .dt <0 .dd always put sendmail in the background without waiting
+  ** .de
+  ** .pp
+  ** Note that if you specify a value other than 0, the output of the child
+  ** process will be put in a temporary file.  If there is some error, you
+  ** will be informed as to where to find the output.
+  */
+  { "shell",		DT_PATH, R_NONE, UL &Shell, 0 },
+  /*
+  ** .pp
+  ** Command to use when spawning a subshell.  By default, the user's login
+  ** shell from \fC/etc/passwd\fP is used.
+  */
+  { "sig_dashes",	DT_BOOL, R_NONE, OPTSIGDASHES, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP, a line containing ``-- '' (note the trailing space) will be inserted before your
+  ** $$signature.  It is \fBstrongly\fP recommended that you not \fIunset\fP
+  ** this variable unless your signature contains just your name.  The
+  ** reason for this is because many software packages use ``-- \n'' to
+  ** detect your signature.  For example, Mutt has the ability to highlight
+  ** the signature in a different color in the built-in pager.
+  */
+  { "sig_on_top",	DT_BOOL, R_NONE, OPTSIGONTOP, 0},
+  /*
+  ** .pp
+  ** If \fIset\fP, the signature will be included before any quoted or forwarded
+  ** text.  It is \fBstrongly\fP recommended that you do not set this variable
+  ** unless you really know what you are doing, and are prepared to take
+  ** some heat from netiquette guardians.
+  */
+  { "signature",	DT_PATH, R_NONE, UL &Signature, UL "~/.signature" },
+  /*
+  ** .pp
+  ** Specifies the filename of your signature, which is appended to all
+  ** outgoing messages.   If the filename ends with a pipe (``|''), it is
+  ** assumed that filename is a shell command and input should be read from
+  ** its standard output.
+  */
+  { "simple_search",	DT_STR,	 R_NONE, UL &SimpleSearch, UL "~f %s | ~s %s" },
+  /*
+  ** .pp
+  ** Specifies how Mutt should expand a simple search into a real search
+  ** pattern.  A simple search is one that does not contain any of the ``~'' pattern
+  ** operators.  See ``$patterns'' for more information on search patterns.
+  ** .pp
+  ** For example, if you simply type ``joe'' at a search or limit prompt, Mutt
+  ** will automatically expand it to the value specified by this variable by
+  ** replacing ``%s'' with the supplied string.
+  ** For the default value, ``joe'' would be expanded to: ``~f joe | ~s joe''.
+  */
+  { "sleep_time",	DT_NUM, R_NONE, UL &SleepTime, 1 },
+  /*
+  ** .pp
+  ** Specifies time, in seconds, to pause while displaying certain informational
+  ** messages, while moving from folder to folder and after expunging
+  ** messages from the current folder.  The default is to pause one second, so
+  ** a value of zero for this option suppresses the pause.
+  */
+  { "smart_wrap",	DT_BOOL, R_PAGER, OPTWRAP, 1 },
+  /*
+  ** .pp
+  ** Controls the display of lines longer than the screen width in the
+  ** internal pager. If \fIset\fP, long lines are wrapped at a word boundary.  If
+  ** \fIunset\fP, lines are simply wrapped at the screen edge. Also see the
+  ** $$markers variable.
+  */
+  { "smileys",		DT_RX,	 R_PAGER, UL &Smileys, UL "(>From )|(:[-^]?[][)(><}{|/DP])" },
+  /*
+  ** .pp
+  ** The \fIpager\fP uses this variable to catch some common false
+  ** positives of $$quote_regexp, most notably smileys and not consider
+  ** a line quoted text if it also matches $$smileys. This mostly
+  ** happens at the beginning of a line.
+  */
+
+
+
+  { "smime_ask_cert_label",	DT_BOOL, R_NONE, OPTASKCERTLABEL, 1 },
+  /*
+  ** .pp
+  ** This flag controls whether you want to be asked to enter a label
+  ** for a certificate about to be added to the database or not. It is
+  ** \fIset\fP by default.
+  ** (S/MIME only)
+  */
+  { "smime_ca_location",	DT_PATH, R_NONE, UL &SmimeCALocation, 0 },
+  /*
+  ** .pp
+  ** This variable contains the name of either a directory, or a file which
+  ** contains trusted certificates for use with OpenSSL.
+  ** (S/MIME only)
+  */
+  { "smime_certificates",	DT_PATH, R_NONE, UL &SmimeCertificates, 0 },
+  /*
+  ** .pp
+  ** Since for S/MIME there is no pubring/secring as with PGP, mutt has to handle
+  ** storage and retrieval of keys by itself. This is very basic right
+  ** now, and keys and certificates are stored in two different
+  ** directories, both named as the hash-value retrieved from
+  ** OpenSSL. There is an index file which contains mailbox-address
+  ** keyid pairs, and which can be manually edited. This option points to
+  ** the location of the certificates.
+  ** (S/MIME only)
+  */
+  { "smime_decrypt_command", 	DT_STR, R_NONE, UL &SmimeDecryptCommand, 0},
+  /*
+  ** .pp
+  ** This format string specifies a command which is used to decrypt
+  ** \fCapplication/x-pkcs7-mime\fP attachments.
+  ** .pp
+  ** The OpenSSL command formats have their own set of \fCprintf(3)\fP-like sequences
+  ** similar to PGP's:
+  ** .dl
+  ** .dt %f .dd Expands to the name of a file containing a message.
+  ** .dt %s .dd Expands to the name of a file containing the signature part
+  ** .          of a \fCmultipart/signed\fP attachment when verifying it.
+  ** .dt %k .dd The key-pair specified with $$smime_default_key
+  ** .dt %c .dd One or more certificate IDs.
+  ** .dt %a .dd The algorithm used for encryption.
+  ** .dt %C .dd CA location:  Depending on whether $$smime_ca_location
+  ** .          points to a directory or file, this expands to
+  ** .          ``-CApath $$smime_ca_location'' or ``-CAfile $$smime_ca_location''.
+  ** .de
+  ** .pp
+  ** For examples on how to configure these formats, see the \fCsmime.rc\fP in
+  ** the \fCsamples/\fP subdirectory which has been installed on your system
+  ** alongside the documentation.
+  ** (S/MIME only)
+  */
+  { "smime_decrypt_use_default_key",	DT_BOOL, R_NONE, OPTSDEFAULTDECRYPTKEY, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP (default) this tells mutt to use the default key for decryption. Otherwise,
+  ** if managing multiple certificate-key-pairs, mutt will try to use the mailbox-address
+  ** to determine the key to use. It will ask you to supply a key, if it can't find one.
+  ** (S/MIME only)
+  */
+  { "smime_sign_as",			DT_SYN,  R_NONE, UL "smime_default_key", 0 },
+  { "smime_default_key",		DT_STR,	 R_NONE, UL &SmimeDefaultKey, 0 },
+  /*
+  ** .pp
+  ** This is the default key-pair to use for signing. This must be set to the
+  ** keyid (the hash-value that OpenSSL generates) to work properly
+  ** (S/MIME only)
+  */
+  { "smime_encrypt_command", 	DT_STR, R_NONE, UL &SmimeEncryptCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to create encrypted S/MIME messages.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_encrypt_with",	DT_STR,	 R_NONE, UL &SmimeCryptAlg, UL "aes256" },
+  /*
+  ** .pp
+  ** This sets the algorithm that should be used for encryption.
+  ** Valid choices are ``aes128'', ``aes192'', ``aes256'', ``des'', ``des3'', ``rc2-40'', ``rc2-64'', ``rc2-128''.
+  ** (S/MIME only)
+  */
+  { "smime_get_cert_command", 	DT_STR, R_NONE, UL &SmimeGetCertCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to extract X509 certificates from a PKCS7 structure.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_get_cert_email_command", 	DT_STR, R_NONE, UL &SmimeGetCertEmailCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to extract the mail address(es) used for storing
+  ** X509 certificates, and for verification purposes (to check whether the
+  ** certificate was issued for the sender's mailbox).
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_get_signer_cert_command", 	DT_STR, R_NONE, UL &SmimeGetSignerCertCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to extract only the signers X509 certificate from a S/MIME
+  ** signature, so that the certificate's owner may get compared to the
+  ** email's ``From:'' field.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_import_cert_command", 	DT_STR, R_NONE, UL &SmimeImportCertCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to import a certificate via smime_keys.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_is_default", DT_BOOL,  R_NONE, OPTSMIMEISDEFAULT, 0},
+  /*
+  ** .pp
+  ** The default behavior of mutt is to use PGP on all auto-sign/encryption
+  ** operations. To override and to use OpenSSL instead this must be \fIset\fP.
+  ** However, this has no effect while replying, since mutt will automatically
+  ** select the same application that was used to sign/encrypt the original
+  ** message.  (Note that this variable can be overridden by unsetting $$crypt_autosmime.)
+  ** (S/MIME only)
+  */
+  { "smime_keys",		DT_PATH, R_NONE, UL &SmimeKeys, 0 },
+  /*
+  ** .pp
+  ** Since for S/MIME there is no pubring/secring as with PGP, mutt has to handle
+  ** storage and retrieval of keys/certs by itself. This is very basic right now,
+  ** and stores keys and certificates in two different directories, both
+  ** named as the hash-value retrieved from OpenSSL. There is an index file
+  ** which contains mailbox-address keyid pair, and which can be manually
+  ** edited. This option points to the location of the private keys.
+  ** (S/MIME only)
+  */
+  { "smime_pk7out_command", 	DT_STR, R_NONE, UL &SmimePk7outCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to extract PKCS7 structures of S/MIME signatures,
+  ** in order to extract the public X509 certificate(s).
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_sign_command", 	DT_STR, R_NONE, UL &SmimeSignCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to created S/MIME signatures of type
+  ** \fCmultipart/signed\fP, which can be read by all mail clients.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_sign_opaque_command", 	DT_STR, R_NONE, UL &SmimeSignOpaqueCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to created S/MIME signatures of type
+  ** \fCapplication/x-pkcs7-signature\fP, which can only be handled by mail
+  ** clients supporting the S/MIME extension.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_timeout",		DT_NUM,	 R_NONE, UL &SmimeTimeout, 300 },
+  /*
+  ** .pp
+  ** The number of seconds after which a cached passphrase will expire if
+  ** not used.
+  ** (S/MIME only)
+  */
+  { "smime_verify_command", 	DT_STR, R_NONE, UL &SmimeVerifyCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to verify S/MIME signatures of type \fCmultipart/signed\fP.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+  { "smime_verify_opaque_command", 	DT_STR, R_NONE, UL &SmimeVerifyOpaqueCommand, 0},
+  /*
+  ** .pp
+  ** This command is used to verify S/MIME signatures of type
+  ** \fCapplication/x-pkcs7-mime\fP.
+  ** .pp
+  ** This is a format string, see the $$smime_decrypt_command command for
+  ** possible \fCprintf(3)\fP-like sequences.
+  ** (S/MIME only)
+  */
+#ifdef USE_SMTP
+# ifdef USE_SASL
+  { "smtp_authenticators", DT_STR, R_NONE, UL &SmtpAuthenticators, UL 0 },
+  /*
+  ** .pp
+  ** This is a colon-delimited list of authentication methods mutt may
+  ** attempt to use to log in to an SMTP server, in the order mutt should
+  ** try them.  Authentication methods are any SASL mechanism, e.g.
+  ** ``digest-md5'', ``gssapi'' or ``cram-md5''.
+  ** This option is case-insensitive. If it is ``unset''
+  ** (the default) mutt will try all available methods, in order from
+  ** most-secure to least-secure.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set smtp_authenticators="digest-md5:cram-md5"
+  ** .te
+  */
+# endif /* USE_SASL */
+  { "smtp_pass", 	DT_STR,  R_NONE, UL &SmtpPass, UL 0 },
+  /*
+  ** .pp
+  ** Specifies the password for your SMTP account.  If \fIunset\fP, Mutt will
+  ** prompt you for your password when you first send mail via SMTP.
+  ** See $$smtp_url to configure mutt to send mail via SMTP.
+  ** .pp
+  ** \fBWarning\fP: you should only use this option when you are on a
+  ** fairly secure machine, because the superuser can read your muttrc even
+  ** if you are the only one who can read the file.
+  */
+  { "smtp_url",		DT_STR, R_NONE, UL &SmtpUrl, UL 0 },
+  /*
+  ** .pp
+  ** Defines the SMTP smarthost where sent messages should relayed for
+  ** delivery. This should take the form of an SMTP URL, e.g.:
+  ** .ts
+  ** smtp[s]://[user[:pass]@]host[:port]
+  ** .te
+  ** .pp
+  ** where ``[...]'' denotes an optional part.
+  ** Setting this variable overrides the value of the $$sendmail
+  ** variable.
+  */
+#endif /* USE_SMTP */
+  { "sort",		DT_SORT, R_INDEX|R_RESORT, UL &Sort, SORT_DATE },
+  /*
+  ** .pp
+  ** Specifies how to sort messages in the ``index'' menu.  Valid values
+  ** are:
+  ** .il
+  ** .dd date or date-sent
+  ** .dd date-received
+  ** .dd from
+  ** .dd mailbox-order (unsorted)
+  ** .dd score
+  ** .dd size
+  ** .dd spam
+  ** .dd subject
+  ** .dd threads
+  ** .dd to
+  ** .ie
+  ** .pp
+  ** You may optionally use the ``reverse-'' prefix to specify reverse sorting
+  ** order (example: ``\fCset sort=reverse-date-sent\fP'').
+  */
+  { "sort_alias",	DT_SORT|DT_SORT_ALIAS,	R_NONE,	UL &SortAlias, SORT_ALIAS },
+  /*
+  ** .pp
+  ** Specifies how the entries in the ``alias'' menu are sorted.  The
+  ** following are legal values:
+  ** .il
+  ** .dd address (sort alphabetically by email address)
+  ** .dd alias (sort alphabetically by alias name)
+  ** .dd unsorted (leave in order specified in .muttrc)
+  ** .ie
+  */
+  { "sort_aux",		DT_SORT|DT_SORT_AUX, R_INDEX|R_RESORT_BOTH, UL &SortAux, SORT_DATE },
+  /*
+  ** .pp
+  ** When sorting by threads, this variable controls how threads are sorted
+  ** in relation to other threads, and how the branches of the thread trees
+  ** are sorted.  This can be set to any value that $$sort can, except
+  ** ``threads'' (in that case, mutt will just use ``date-sent'').  You can also
+  ** specify the ``last-'' prefix in addition to the ``reverse-'' prefix, but ``last-''
+  ** must come after ``reverse-''.  The ``last-'' prefix causes messages to be
+  ** sorted against its siblings by which has the last descendant, using
+  ** the rest of $$sort_aux as an ordering.  For instance,
+  ** .ts
+  ** set sort_aux=last-date-received
+  ** .te
+  ** .pp
+  ** would mean that if a new message is received in a
+  ** thread, that thread becomes the last one displayed (or the first, if
+  ** you have ``\fCset sort=reverse-threads\fP''.)
+  ** .pp
+  ** Note: For reversed $$sort
+  ** order $$sort_aux is reversed again (which is not the right thing to do,
+  ** but kept to not break any existing configuration setting).
+  */
+  { "sort_browser",	DT_SORT|DT_SORT_BROWSER, R_NONE, UL &BrowserSort, SORT_ALPHA },
+  /*
+  ** .pp
+  ** Specifies how to sort entries in the file browser.  By default, the
+  ** entries are sorted alphabetically.  Valid values:
+  ** .il
+  ** .dd alpha (alphabetically)
+  ** .dd date
+  ** .dd size
+  ** .dd unsorted
+  ** .ie
+  ** .pp
+  ** You may optionally use the ``reverse-'' prefix to specify reverse sorting
+  ** order (example: ``\fCset sort_browser=reverse-date\fP'').
+  */
+  { "sort_re",		DT_BOOL, R_INDEX|R_RESORT|R_RESORT_INIT, OPTSORTRE, 1 },
+  /*
+  ** .pp
+  ** This variable is only useful when sorting by threads with
+  ** $$strict_threads \fIunset\fP.  In that case, it changes the heuristic
+  ** mutt uses to thread messages by subject.  With $$sort_re \fIset\fP, mutt will
+  ** only attach a message as the child of another message by subject if
+  ** the subject of the child message starts with a substring matching the
+  ** setting of $$reply_regexp.  With $$sort_re \fIunset\fP, mutt will attach
+  ** the message whether or not this is the case, as long as the
+  ** non-$$reply_regexp parts of both messages are identical.
+  */
+  { "spam_separator",   DT_STR, R_NONE, UL &SpamSep, UL "," },
+  /*
+  ** .pp
+  ** This variable controls what happens when multiple spam headers
+  ** are matched: if \fIunset\fP, each successive header will overwrite any
+  ** previous matches value for the spam label. If \fIset\fP, each successive
+  ** match will append to the previous, using this variable's value as a
+  ** separator.
+  */
+  { "spoolfile",	DT_PATH, R_NONE, UL &Spoolfile, 0 },
+  /*
+  ** .pp
+  ** If your spool mailbox is in a non-default place where Mutt cannot find
+  ** it, you can specify its location with this variable.  Mutt will
+  ** initially set this variable to the value of the environment
+  ** variable \fC$$$MAIL\fP or \fC$$$MAILDIR\fP if either is defined.
+  */
+#if defined(USE_SSL)
+#ifdef USE_SSL_GNUTLS
+  { "ssl_ca_certificates_file", DT_PATH, R_NONE, UL &SslCACertFile, 0 },
+  /*
+  ** .pp
+  ** This variable specifies a file containing trusted CA certificates.
+  ** Any server certificate that is signed with one of these CA
+  ** certificates is also automatically accepted.
+  ** .pp
+  ** Example:
+  ** .ts
+  ** set ssl_ca_certificates_file=/etc/ssl/certs/ca-certificates.crt
+  ** .te
+  */
+#endif /* USE_SSL_GNUTLS */
+  { "ssl_client_cert", DT_PATH, R_NONE, UL &SslClientCert, 0 },
+  /*
+  ** .pp
+  ** The file containing a client certificate and its associated private
+  ** key.
+  */
+  { "ssl_force_tls",		DT_BOOL, R_NONE, OPTSSLFORCETLS, 0 },
+  /*
+   ** .pp
+   ** If this variable is \fIset\fP, Mutt will require that all connections
+   ** to remote servers be encrypted. Furthermore it will attempt to
+   ** negotiate TLS even if the server does not advertise the capability,
+   ** since it would otherwise have to abort the connection anyway. This
+   ** option supersedes $$ssl_starttls.
+   */
+# ifdef USE_SSL_GNUTLS
+  { "ssl_min_dh_prime_bits", DT_NUM, R_NONE, UL &SslDHPrimeBits, 0 },
+  /*
+  ** .pp
+  ** This variable specifies the minimum acceptable prime size (in bits)
+  ** for use in any Diffie-Hellman key exchange. A value of 0 will use
+  ** the default from the GNUTLS library.
+  */
+# endif /* USE_SSL_GNUTLS */
+  { "ssl_starttls", DT_QUAD, R_NONE, OPT_SSLSTARTTLS, M_YES },
+  /*
+  ** .pp
+  ** If \fIset\fP (the default), mutt will attempt to use \fCSTARTTLS\fP on servers
+  ** advertising the capability. When \fIunset\fP, mutt will not attempt to
+  ** use \fCSTARTTLS\fP regardless of the server's capabilities.
+  */
+# ifdef USE_SSL_OPENSSL
+  { "ssl_use_sslv2", DT_BOOL, R_NONE, OPTSSLV2, 0 },
+  /*
+  ** .pp
+  ** This variable specifies whether to attempt to use SSLv2 in the
+  ** SSL authentication process. Note that SSLv2 and SSLv3 are now
+  ** considered fundamentally insecure and are no longer recommended.
+  */
+# endif /* defined USE_SSL_OPENSSL */
+  { "ssl_use_sslv3", DT_BOOL, R_NONE, OPTSSLV3, 0 },
+  /*
+  ** .pp
+  ** This variable specifies whether to attempt to use SSLv3 in the
+  ** SSL authentication process. Note that SSLv2 and SSLv3 are now
+  ** considered fundamentally insecure and are no longer recommended.
+  */
+  { "ssl_use_tlsv1", DT_BOOL, R_NONE, OPTTLSV1, 1 },
+  /*
+  ** .pp
+  ** This variable specifies whether to attempt to use TLSv1.0 in the
+  ** SSL authentication process.
+  */
+  { "ssl_use_tlsv1_1", DT_BOOL, R_NONE, OPTTLSV1_1, 1 },
+  /*
+  ** .pp
+  ** This variable specifies whether to attempt to use TLSv1.1 in the
+  ** SSL authentication process.
+  */
+  { "ssl_use_tlsv1_2", DT_BOOL, R_NONE, OPTTLSV1_2, 1 },
+  /*
+  ** .pp
+  ** This variable specifies whether to attempt to use TLSv1.2 in the
+  ** SSL authentication process.
+  */
+#ifdef USE_SSL_OPENSSL
+  { "ssl_usesystemcerts", DT_BOOL, R_NONE, OPTSSLSYSTEMCERTS, 1 },
+  /*
+  ** .pp
+  ** If set to \fIyes\fP, mutt will use CA certificates in the
+  ** system-wide certificate store when checking if a server certificate
+  ** is signed by a trusted CA.
+  */
+#endif
+  { "ssl_verify_dates", DT_BOOL, R_NONE, OPTSSLVERIFYDATES, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP (the default), mutt will not automatically accept a server
+  ** certificate that is either not yet valid or already expired. You should
+  ** only unset this for particular known hosts, using the
+  ** \fC$<account-hook>\fP function.
+  */
+  { "ssl_verify_host", DT_BOOL, R_NONE, OPTSSLVERIFYHOST, 1 },
+  /*
+  ** .pp
+  ** If \fIset\fP (the default), mutt will not automatically accept a server
+  ** certificate whose host name does not match the host used in your folder
+  ** URL. You should only unset this for particular known hosts, using
+  ** the \fC$<account-hook>\fP function.
+  */
+  { "ssl_ciphers", DT_STR, R_NONE, UL &SslCiphers, UL 0 },
+  /*
+  ** .pp
+  ** Contains a colon-seperated list of ciphers to use when using SSL.
+  ** For OpenSSL, see ciphers(1) for the syntax of the string.
+  ** .pp
+  ** For GnuTLS, this option will be used in place of "NORMAL" at the
+  ** start of the priority string.  See gnutls_priority_init(3) for the
+  ** syntax and more details. (Note: GnuTLS version 2.1.7 or higher is
+  ** required.)
+  */
+#endif /* defined(USE_SSL) */
+  { "status_chars",	DT_STR,	 R_BOTH, UL &StChars, UL "-*%A" },
+  /*
+  ** .pp
+  ** Controls the characters used by the ``%r'' indicator in
+  ** $$status_format. The first character is used when the mailbox is
+  ** unchanged. The second is used when the mailbox has been changed, and
+  ** it needs to be resynchronized. The third is used if the mailbox is in
+  ** read-only mode, or if the mailbox will not be written when exiting
+  ** that mailbox (You can toggle whether to write changes to a mailbox
+  ** with the \fC<toggle-write>\fP operation, bound by default to ``%''). The fourth
+  ** is used to indicate that the current folder has been opened in attach-
+  ** message mode (Certain operations like composing a new mail, replying,
+  ** forwarding, etc. are not permitted in this mode).
+  */
+  { "status_format",	DT_STR,	 R_BOTH, UL &Status, UL "-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%>-(%P)---" },
+  /*
+  ** .pp
+  ** Controls the format of the status line displayed in the ``index''
+  ** menu.  This string is similar to $$index_format, but has its own
+  ** set of \fCprintf(3)\fP-like sequences:
+  ** .dl
+  ** .dt %b  .dd number of mailboxes with new mail *
+  ** .dt %d  .dd number of deleted messages *
+  ** .dt %f  .dd the full pathname of the current mailbox
+  ** .dt %F  .dd number of flagged messages *
+  ** .dt %h  .dd local hostname
+  ** .dt %l  .dd size (in bytes) of the current mailbox *
+  ** .dt %L  .dd size (in bytes) of the messages shown
+  **             (i.e., which match the current limit) *
+  ** .dt %m  .dd the number of messages in the mailbox *
+  ** .dt %M  .dd the number of messages shown (i.e., which match the current limit) *
+  ** .dt %n  .dd number of new messages in the mailbox *
+  ** .dt %o  .dd number of old unread messages *
+  ** .dt %p  .dd number of postponed messages *
+  ** .dt %P  .dd percentage of the way through the index
+  ** .dt %r  .dd modified/read-only/won't-write/attach-message indicator,
+  **             according to $$status_chars
+  ** .dt %s  .dd current sorting mode ($$sort)
+  ** .dt %S  .dd current aux sorting method ($$sort_aux)
+  ** .dt %t  .dd number of tagged messages *
+  ** .dt %u  .dd number of unread messages *
+  ** .dt %v  .dd Mutt version string
+  ** .dt %V  .dd currently active limit pattern, if any *
+  ** .dt %>X .dd right justify the rest of the string and pad with ``X''
+  ** .dt %|X .dd pad to the end of the line with ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** For an explanation of ``soft-fill'', see the $$index_format documentation.
+  ** .pp
+  ** * = can be optionally printed if nonzero
+  ** .pp
+  ** Some of the above sequences can be used to optionally print a string
+  ** if their value is nonzero.  For example, you may only want to see the
+  ** number of flagged messages if such messages exist, since zero is not
+  ** particularly meaningful.  To optionally print a string based upon one
+  ** of the above sequences, the following construct is used:
+  ** .pp
+  **  \fC%?<sequence_char>?<optional_string>?\fP
+  ** .pp
+  ** where \fIsequence_char\fP is a character from the table above, and
+  ** \fIoptional_string\fP is the string you would like printed if
+  ** \fIsequence_char\fP is nonzero.  \fIoptional_string\fP \fBmay\fP contain
+  ** other sequences as well as normal text, but you may \fBnot\fP nest
+  ** optional strings.
+  ** .pp
+  ** Here is an example illustrating how to optionally print the number of
+  ** new messages in a mailbox:
+  ** .pp
+  ** \fC%?n?%n new messages.?\fP
+  ** .pp
+  ** You can also switch between two strings using the following construct:
+  ** .pp
+  ** \fC%?<sequence_char>?<if_string>&<else_string>?\fP
+  ** .pp
+  ** If the value of \fIsequence_char\fP is non-zero, \fIif_string\fP will
+  ** be expanded, otherwise \fIelse_string\fP will be expanded.
+  ** .pp
+  ** You can force the result of any \fCprintf(3)\fP-like sequence to be lowercase
+  ** by prefixing the sequence character with an underscore (``_'') sign.
+  ** For example, if you want to display the local hostname in lowercase,
+  ** you would use: ``\fC%_h\fP''.
+  ** .pp
+  ** If you prefix the sequence character with a colon (``:'') character, mutt
+  ** will replace any dots in the expansion by underscores. This might be helpful
+  ** with IMAP folders that don't like dots in folder names.
+  */
+  { "status_on_top",	DT_BOOL, R_BOTH, OPTSTATUSONTOP, 0 },
+  /*
+  ** .pp
+  ** Setting this variable causes the ``status bar'' to be displayed on
+  ** the first line of the screen rather than near the bottom. If $$help
+  ** is \fIset\fP, too it'll be placed at the bottom.
+  */
+  { "strict_threads",	DT_BOOL, R_RESORT|R_RESORT_INIT|R_INDEX, OPTSTRICTTHREADS, 0 },
+  /*
+  ** .pp
+  ** If \fIset\fP, threading will only make use of the ``In-Reply-To'' and
+  ** ``References:'' fields when you $$sort by message threads.  By
+  ** default, messages with the same subject are grouped together in
+  ** ``pseudo threads.''. This may not always be desirable, such as in a
+  ** personal mailbox where you might have several unrelated messages with
+  ** the subjects like ``hi'' which will get grouped together. See also
+  ** $$sort_re for a less drastic way of controlling this
+  ** behavior.
+  */
+  { "suspend",		DT_BOOL, R_NONE, OPTSUSPEND, 1 },
+  /*
+  ** .pp
+  ** When \fIunset\fP, mutt won't stop when the user presses the terminal's
+  ** \fIsusp\fP key, usually ``^Z''. This is useful if you run mutt
+  ** inside an xterm using a command like ``\fCxterm -e mutt\fP''.
+  */
+  { "text_flowed", 	DT_BOOL, R_NONE, OPTTEXTFLOWED,  0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will generate ``format=flowed'' bodies with a content type
+  ** of ``\fCtext/plain; format=flowed\fP''.
+  ** This format is easier to handle for some mailing software, and generally
+  ** just looks like ordinary text.  To actually make use of this format's
+  ** features, you'll need support in your editor.
+  ** .pp
+  ** Note that $$indent_string is ignored when this option is \fIset\fP.
+  */
+  { "thorough_search",	DT_BOOL, R_NONE, OPTTHOROUGHSRC, 1 },
+  /*
+  ** .pp
+  ** Affects the \fC~b\fP and \fC~h\fP search operations described in
+  ** section ``$patterns''.  If \fIset\fP, the headers and body/attachments of
+  ** messages to be searched are decoded before searching. If \fIunset\fP,
+  ** messages are searched as they appear in the folder.
+  ** .pp
+  ** Users searching attachments or for non-ASCII characters should \fIset\fP
+  ** this value because decoding also includes MIME parsing/decoding and possible
+  ** character set conversions. Otherwise mutt will attempt to match against the
+  ** raw message received (for example quoted-printable encoded or with encoded
+  ** headers) which may lead to incorrect search results.
+  */
+  { "thread_received",	DT_BOOL, R_RESORT|R_RESORT_INIT|R_INDEX, OPTTHREADRECEIVED, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt uses the date received rather than the date sent
+  ** to thread messages by subject.
+  */
+  { "tilde",		DT_BOOL, R_PAGER, OPTTILDE, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, the internal-pager will pad blank lines to the bottom of the
+  ** screen with a tilde (``~'').
+  */
+  { "time_inc",		DT_NUM,	 R_NONE, UL &TimeInc, 0 },
+  /*
+  ** .pp
+  ** Along with $$read_inc, $$write_inc, and $$net_inc, this
+  ** variable controls the frequency with which progress updates are
+  ** displayed. It suppresses updates less than $$time_inc milliseconds
+  ** apart. This can improve throughput on systems with slow terminals,
+  ** or when running mutt on a remote system.
+  ** .pp
+  ** Also see the ``$tuning'' section of the manual for performance considerations.
+  */
+  { "timeout",		DT_NUM,	 R_NONE, UL &Timeout, 600 },
+  /*
+  ** .pp
+  ** When Mutt is waiting for user input either idling in menus or
+  ** in an interactive prompt, Mutt would block until input is
+  ** present. Depending on the context, this would prevent certain
+  ** operations from working, like checking for new mail or keeping
+  ** an IMAP connection alive.
+  ** .pp
+  ** This variable controls how many seconds Mutt will at most wait
+  ** until it aborts waiting for input, performs these operations and
+  ** continues to wait for input.
+  ** .pp
+  ** A value of zero or less will cause Mutt to never time out.
+  */
+  { "tmpdir",		DT_PATH, R_NONE, UL &Tempdir, 0 },
+  /*
+  ** .pp
+  ** This variable allows you to specify where Mutt will place its
+  ** temporary files needed for displaying and composing messages.  If
+  ** this variable is not set, the environment variable \fC$$$TMPDIR\fP is
+  ** used.  If \fC$$$TMPDIR\fP is not set then ``\fC/tmp\fP'' is used.
+  */
+  { "to_chars",		DT_STR,	 R_BOTH, UL &Tochars, UL " +TCFL" },
+  /*
+  ** .pp
+  ** Controls the character used to indicate mail addressed to you.  The
+  ** first character is the one used when the mail is \fInot\fP addressed to your
+  ** address.  The second is used when you are the only
+  ** recipient of the message.  The third is when your address
+  ** appears in the ``To:'' header field, but you are not the only recipient of
+  ** the message.  The fourth character is used when your
+  ** address is specified in the ``Cc:'' header field, but you are not the only
+  ** recipient.  The fifth character is used to indicate mail that was sent
+  ** by \fIyou\fP.  The sixth character is used to indicate when a mail
+  ** was sent to a mailing-list you subscribe to.
+  */
+  {"ts_icon_format",	DT_STR,  R_BOTH, UL &TSIconFormat, UL "M%?n?AIL&ail?"},
+  /*
+  ** .pp
+  ** Controls the format of the icon title, as long as ``$$ts_enabled'' is set.
+  ** This string is identical in formatting to the one used by
+  ** ``$$status_format''.
+  */
+  {"ts_enabled",	DT_BOOL,  R_BOTH, OPTTSENABLED, 0},
+  /* The default must be off to force in the validity checking. */
+  /*
+  ** .pp
+  ** Controls whether mutt tries to set the terminal status line and icon name.
+  ** Most terminal emulators emulate the status line in the window title.
+  */
+  {"ts_status_format",	DT_STR,   R_BOTH, UL &TSStatusFormat, UL "Mutt with %?m?%m messages&no messages?%?n? [%n NEW]?"},
+  /*
+  ** .pp
+  ** Controls the format of the terminal status line (or window title),
+  ** provided that ``$$ts_enabled'' has been set. This string is identical in
+  ** formatting to the one used by ``$$status_format''.
+  */
+#ifdef USE_SOCKET
+  { "tunnel",            DT_STR, R_NONE, UL &Tunnel, UL 0 },
+  /*
+  ** .pp
+  ** Setting this variable will cause mutt to open a pipe to a command
+  ** instead of a raw socket. You may be able to use this to set up
+  ** preauthenticated connections to your IMAP/POP3/SMTP server. Example:
+  ** .ts
+  ** set tunnel="ssh -q mailhost.net /usr/local/libexec/imapd"
+  ** .te
+  ** .pp
+  ** Note: For this example to work you must be able to log in to the remote
+  ** machine without having to enter a password.
+  ** .pp
+  ** When set, Mutt uses the tunnel for all remote connections.
+  ** Please see ``$account-hook'' in the manual for how to use different
+  ** tunnel commands per connection.
+  */
+#endif
+  { "uncollapse_jump", 	DT_BOOL, R_NONE, OPTUNCOLLAPSEJUMP, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will jump to the next unread message, if any,
+  ** when the current thread is \fIun\fPcollapsed.
+  */
+  { "use_8bitmime",	DT_BOOL, R_NONE, OPTUSE8BITMIME, 0 },
+  /*
+  ** .pp
+  ** \fBWarning:\fP do not set this variable unless you are using a version
+  ** of sendmail which supports the \fC-B8BITMIME\fP flag (such as sendmail
+  ** 8.8.x) or you may not be able to send mail.
+  ** .pp
+  ** When \fIset\fP, Mutt will invoke $$sendmail with the \fC-B8BITMIME\fP
+  ** flag when sending 8-bit messages to enable ESMTP negotiation.
+  */
+  { "use_domain",	DT_BOOL, R_NONE, OPTUSEDOMAIN, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will qualify all local addresses (ones without the
+  ** ``@host'' portion) with the value of $$hostname.  If \fIunset\fP, no
+  ** addresses will be qualified.
+  */
+  { "use_envelope_from", 	DT_BOOL, R_NONE, OPTENVFROM, 0 },
+  /*
+   ** .pp
+   ** When \fIset\fP, mutt will set the \fIenvelope\fP sender of the message.
+   ** If $$envelope_from_address is \fIset\fP, it will be used as the sender
+   ** address. If \fIunset\fP, mutt will attempt to derive the sender from the
+   ** ``From:'' header.
+   ** .pp
+   ** Note that this information is passed to sendmail command using the
+   ** \fC-f\fP command line switch. Therefore setting this option is not useful
+   ** if the $$sendmail variable already contains \fC-f\fP or if the
+   ** executable pointed to by $$sendmail doesn't support the \fC-f\fP switch.
+   */
+  { "envelope_from",	DT_SYN,  R_NONE, UL "use_envelope_from", 0 },
+  /*
+  */
+  { "use_from",		DT_BOOL, R_NONE, OPTUSEFROM, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will generate the ``From:'' header field when
+  ** sending messages.  If \fIunset\fP, no ``From:'' header field will be
+  ** generated unless the user explicitly sets one using the ``$my_hdr''
+  ** command.
+  */
+#ifdef HAVE_LIBIDN
+  { "use_idn",		DT_BOOL, R_BOTH, OPTUSEIDN, 1},
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will show you international domain names decoded.
+  ** Note: You can use IDNs for addresses even if this is \fIunset\fP.
+  ** This variable only affects decoding.
+  */
+#endif /* HAVE_LIBIDN */
+#ifdef HAVE_GETADDRINFO
+  { "use_ipv6",		DT_BOOL, R_NONE, OPTUSEIPV6, 1},
+  /*
+  ** .pp
+  ** When \fIset\fP, Mutt will look for IPv6 addresses of hosts it tries to
+  ** contact.  If this option is \fIunset\fP, Mutt will restrict itself to IPv4 addresses.
+  ** Normally, the default should work.
+  */
+#endif /* HAVE_GETADDRINFO */
+  { "user_agent",	DT_BOOL, R_NONE, OPTXMAILER, 1},
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will add a ``User-Agent:'' header to outgoing
+  ** messages, indicating which version of mutt was used for composing
+  ** them.
+  */
+  { "visual",		DT_PATH, R_NONE, UL &Visual, 0 },
+  /*
+  ** .pp
+  ** Specifies the visual editor to invoke when the ``\fC~v\fP'' command is
+  ** given in the built-in editor.
+  */
+  { "wait_key",		DT_BOOL, R_NONE, OPTWAITKEY, 1 },
+  /*
+  ** .pp
+  ** Controls whether Mutt will ask you to press a key after an external command
+  ** has been invoked by these functions: \fC<shell-escape>\fP,
+  ** \fC<pipe-message>\fP, \fC<pipe-entry>\fP, \fC<print-message>\fP,
+  ** and \fC<print-entry>\fP commands.
+  ** .pp
+  ** It is also used when viewing attachments with ``$auto_view'', provided
+  ** that the corresponding mailcap entry has a \fIneedsterminal\fP flag,
+  ** and the external program is interactive.
+  ** .pp
+  ** When \fIset\fP, Mutt will always ask for a key. When \fIunset\fP, Mutt will wait
+  ** for a key only if the external command returned a non-zero status.
+  */
+  { "weed",		DT_BOOL, R_NONE, OPTWEED, 1 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will weed headers when displaying, forwarding,
+  ** printing, or replying to messages.
+  */
+  { "wrap",             DT_NUM,  R_PAGER, UL &Wrap, 0 },
+  /*
+  ** .pp
+  ** When set to a positive value, mutt will wrap text at $$wrap characters.
+  ** When set to a negative value, mutt will wrap text so that there are $$wrap
+  ** characters of empty space on the right side of the terminal. Setting it
+  ** to zero makes mutt wrap at the terminal width.
+  ** .pp
+  ** Also see $$reflow_wrap.
+  */
+  { "wrap_headers",     DT_NUM,  R_PAGER, UL &WrapHeaders, 78 },
+  /*
+  ** .pp
+  ** This option specifies the number of characters to use for wrapping
+  ** an outgoing message's headers. Allowed values are between 78 and 998
+  ** inclusive.
+  ** .pp
+  ** \fBNote:\fP This option usually shouldn't be changed. RFC5233
+  ** recommends a line length of 78 (the default), so \fBplease only change
+  ** this setting when you know what you're doing\fP.
+  */
+  { "wrap_search",	DT_BOOL, R_NONE, OPTWRAPSEARCH, 1 },
+  /*
+  ** .pp
+  ** Controls whether searches wrap around the end.
+  ** .pp
+  ** When \fIset\fP, searches will wrap around the first (or last) item. When
+  ** \fIunset\fP, incremental searches will not wrap.
+  */
+  { "wrapmargin",	DT_NUM,	 R_PAGER, UL &Wrap, 0 },
+  /*
+  ** .pp
+  ** (DEPRECATED) Equivalent to setting $$wrap with a negative value.
+  */
+  { "write_bcc",	DT_BOOL, R_NONE, OPTWRITEBCC, 1},
+  /*
+  ** .pp
+  ** Controls whether mutt writes out the ``Bcc:'' header when preparing
+  ** messages to be sent.  Exim users may wish to unset this. If mutt
+  ** is set to deliver directly via SMTP (see $$smtp_url), this
+  ** option does nothing: mutt will never write out the ``Bcc:'' header
+  ** in this case.
+  */
+  { "write_inc",	DT_NUM,	 R_NONE, UL &WriteInc, 10 },
+  /*
+  ** .pp
+  ** When writing a mailbox, a message will be printed every
+  ** $$write_inc messages to indicate progress.  If set to 0, only a
+  ** single message will be displayed before writing a mailbox.
+  ** .pp
+  ** Also see the $$read_inc, $$net_inc and $$time_inc variables and the
+  ** ``$tuning'' section of the manual for performance considerations.
+  */
+  {"xterm_icon",	DT_SYN,  R_NONE, UL "ts_icon_format", 0 },
+  /*
+  */
+  {"xterm_title",	DT_SYN,  R_NONE, UL "ts_status_format", 0 },
+  /*
+  */
+  {"xterm_set_titles",	DT_SYN,  R_NONE, UL "ts_enabled", 0 },
+  /*
+  */
+  /*--*/
+  { NULL, 0, 0, 0, 0 }
+};
+
+const struct mapping_t SortMethods[] = {
+  { "date",		SORT_DATE },
+  { "date-sent",	SORT_DATE },
+  { "date-received",	SORT_RECEIVED },
+  { "mailbox-order",	SORT_ORDER },
+  { "subject",		SORT_SUBJECT },
+  { "from",		SORT_FROM },
+  { "size",		SORT_SIZE },
+  { "threads",		SORT_THREADS },
+  { "to",		SORT_TO },
+  { "score",		SORT_SCORE },
+  { "spam",		SORT_SPAM },
+  { NULL,               0 }
+};
+
+/* same as SortMethods, but with "threads" replaced by "date" */
+
+const struct mapping_t SortAuxMethods[] = {
+  { "date",		SORT_DATE },
+  { "date-sent",	SORT_DATE },
+  { "date-received",	SORT_RECEIVED },
+  { "mailbox-order",	SORT_ORDER },
+  { "subject",		SORT_SUBJECT },
+  { "from",		SORT_FROM },
+  { "size",		SORT_SIZE },
+  { "threads",		SORT_DATE },	/* note: sort_aux == threads
+					 * isn't possible.
+					 */
+  { "to",		SORT_TO },
+  { "score",		SORT_SCORE },
+  { "spam",		SORT_SPAM },
+  { NULL,               0 }
+};
+
+
+const struct mapping_t SortBrowserMethods[] = {
+  { "alpha",	SORT_SUBJECT },
+  { "date",	SORT_DATE },
+  { "size",	SORT_SIZE },
+  { "unsorted",	SORT_ORDER },
+  { NULL,       0 }
+};
+
+const struct mapping_t SortAliasMethods[] = {
+  { "alias",	SORT_ALIAS },
+  { "address",	SORT_ADDRESS },
+  { "unsorted", SORT_ORDER },
+  { NULL,       0 }
+};
+
+const struct mapping_t SortKeyMethods[] = {
+  { "address",	SORT_ADDRESS },
+  { "date",	SORT_DATE },
+  { "keyid",	SORT_KEYID },
+  { "trust",	SORT_TRUST },
+  { NULL,       0 }
+};
+
+
+/* functions used to parse commands in a rc file */
+
+static int parse_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_spam_list (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unlist (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+
+static int parse_group (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+
+static int parse_lists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unlists (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_alias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unalias (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_ignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unignore (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_source (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_set (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_my_hdr (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unmy_hdr (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_subscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unsubscribe (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_attachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unattachments (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+
+
+static int parse_alternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+static int parse_unalternates (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+
+/* Parse -group arguments */
+static int parse_group_context (group_context_t **ctx, BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err);
+
+
+struct command_t
+{
+  char *name;
+  int (*func) (BUFFER *, BUFFER *, unsigned long, BUFFER *);
+  unsigned long data;
+};
+
+const struct command_t Commands[] = {
+  { "alternates",	parse_alternates,	0 },
+  { "unalternates",	parse_unalternates,	0 },
+#ifdef USE_SOCKET
+  { "account-hook",     mutt_parse_hook,        M_ACCOUNTHOOK },
+#endif
+  { "alias",		parse_alias,		0 },
+  { "attachments",	parse_attachments,	0 },
+  { "unattachments",parse_unattachments,0 },
+  { "auto_view",	parse_list,		UL &AutoViewList },
+  { "alternative_order",	parse_list,	UL &AlternativeOrderList},
+  { "bind",		mutt_parse_bind,	0 },
+  { "charset-hook",	mutt_parse_hook,	M_CHARSETHOOK },
+#ifdef HAVE_COLOR
+  { "color",		mutt_parse_color,	0 },
+  { "uncolor",		mutt_parse_uncolor,	0 },
+#endif
+  { "exec",		mutt_parse_exec,	0 },
+  { "fcc-hook",		mutt_parse_hook,	M_FCCHOOK },
+  { "fcc-save-hook",	mutt_parse_hook,	M_FCCHOOK | M_SAVEHOOK },
+  { "folder-hook",	mutt_parse_hook,	M_FOLDERHOOK },
+  { "group",		parse_group,		M_GROUP },
+  { "ungroup",		parse_group,		M_UNGROUP },
+  { "hdr_order",	parse_list,		UL &HeaderOrderList },
+#ifdef HAVE_ICONV
+  { "iconv-hook",	mutt_parse_hook,	M_ICONVHOOK },
+#endif
+  { "ignore",		parse_ignore,		0 },
+  { "lists",		parse_lists,		0 },
+  { "macro",		mutt_parse_macro,	0 },
+  { "mailboxes",	mutt_parse_mailboxes,	M_MAILBOXES },
+  { "unmailboxes",	mutt_parse_mailboxes,	M_UNMAILBOXES },
+  { "message-hook",	mutt_parse_hook,	M_MESSAGEHOOK },
+  { "mbox-hook",	mutt_parse_hook,	M_MBOXHOOK },
+  { "mime_lookup",	parse_list,	UL &MimeLookupList },
+  { "unmime_lookup",	parse_unlist,	UL &MimeLookupList },
+  { "mono",		mutt_parse_mono,	0 },
+  { "my_hdr",		parse_my_hdr,		0 },
+  { "pgp-hook",		mutt_parse_hook,	M_CRYPTHOOK },
+  { "crypt-hook",	mutt_parse_hook,	M_CRYPTHOOK },
+  { "push",		mutt_parse_push,	0 },
+  { "reply-hook",	mutt_parse_hook,	M_REPLYHOOK },
+  { "reset",		parse_set,		M_SET_RESET },
+  { "save-hook",	mutt_parse_hook,	M_SAVEHOOK },
+  { "score",		mutt_parse_score,	0 },
+  { "send-hook",	mutt_parse_hook,	M_SENDHOOK },
+  { "send2-hook",	mutt_parse_hook,	M_SEND2HOOK },
+  { "set",		parse_set,		0 },
+  { "source",		parse_source,		0 },
+  { "spam",		parse_spam_list,	M_SPAM },
+  { "nospam",		parse_spam_list,	M_NOSPAM },
+  { "subscribe",	parse_subscribe,	0 },
+  { "toggle",		parse_set,		M_SET_INV },
+  { "unalias",		parse_unalias,		0 },
+  { "unalternative_order",parse_unlist,		UL &AlternativeOrderList },
+  { "unauto_view",	parse_unlist,		UL &AutoViewList },
+  { "unhdr_order",	parse_unlist,		UL &HeaderOrderList },
+  { "unhook",		mutt_parse_unhook,	0 },
+  { "unignore",		parse_unignore,		0 },
+  { "unlists",		parse_unlists,		0 },
+  { "unmono",		mutt_parse_unmono,	0 },
+  { "unmy_hdr",		parse_unmy_hdr,		0 },
+  { "unscore",		mutt_parse_unscore,	0 },
+  { "unset",		parse_set,		M_SET_UNSET },
+  { "unsubscribe",	parse_unsubscribe,	0 },
+  { NULL,		NULL,			0 }
+};
diff -uNp -r mutt.b/mutt.h mutt.a/mutt.h
--- mutt.b/mutt.h	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/mutt.h	2015-09-23 10:28:45.000000000 +0200
@@ -185,6 +185,7 @@ enum
   M_DELETE,
   M_UNDELETE,
   M_DELETED,
+  M_APPENDED,
   M_FLAG,
   M_TAG,
   M_UNTAG,
@@ -713,6 +714,7 @@ typedef struct header
   unsigned int mime : 1;    		/* has a MIME-Version header? */
   unsigned int flagged : 1; 		/* marked important? */
   unsigned int tagged : 1;
+  unsigned int appended : 1; /* has been saved */
   unsigned int deleted : 1;
   unsigned int changed : 1;
   unsigned int attach_del : 1; 		/* has an attachment marked for deletion */
@@ -885,6 +887,7 @@ typedef struct _context
   int new;			/* how many new messages? */
   int unread;			/* how many unread messages? */
   int deleted;			/* how many deleted messages */
+  int appended;                 /* how many saved messages? */
   int flagged;			/* how many flagged messages */
   int msgnotreadyet;		/* which msg "new" in pager, -1 if none */
 
diff -uNp -r mutt.b/mutt.h.orig mutt.a/mutt.h.orig
--- mutt.b/mutt.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ mutt.a/mutt.h.orig	2015-09-23 10:25:53.000000000 +0200
@@ -0,0 +1,967 @@
+
+/*
+ * Copyright (C) 1996-2002, 2010 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 2004 g10 Code GmbH
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#ifndef MUTT_H
+#define MUTT_H 
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h> /* needed for SEEK_SET */
+#endif
+#ifdef HAVE_UNIX_H
+# include <unix.h>   /* needed for snprintf on QNX. */
+#endif
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <signal.h>
+/* On OS X 10.5.x, wide char functions are inlined by default breaking
+ * --without-wc-funcs compilation
+ */
+#ifdef __APPLE_CC__
+#define _DONT_USE_CTYPE_INLINE_
+#endif
+#ifdef HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+#if defined(HAVE_WCTYPE_H) && defined(HAVE_WC_FUNCS)
+# include <wctype.h>
+#endif
+
+#ifndef _POSIX_PATH_MAX
+#include <limits.h>
+#endif
+
+#include <pwd.h>
+#include <grp.h>
+
+#include "rfc822.h"
+#include "hash.h"
+#include "charset.h"
+
+#ifndef HAVE_WC_FUNCS
+# ifdef MB_LEN_MAX
+#  undef MB_LEN_MAX
+# endif
+# define MB_LEN_MAX 16
+#endif
+
+/* nifty trick I stole from ELM 2.5alpha. */
+#ifdef MAIN_C
+#define WHERE 
+#define INITVAL(x) = x
+#else
+#define WHERE extern
+#define INITVAL(x) 
+#endif
+
+#define WHERE_DEFINED 1
+
+#include "mutt_regex.h"
+
+/* flags for mutt_enter_string() */
+#define  M_ALIAS   1      /* do alias "completion" by calling up the alias-menu */
+#define  M_FILE    (1<<1) /* do file completion */
+#define  M_EFILE   (1<<2) /* do file completion, plus incoming folders */
+#define  M_CMD     (1<<3) /* do completion on previous word */
+#define  M_PASS    (1<<4) /* password mode (no echo) */
+#define  M_CLEAR   (1<<5) /* clear input if printable character is pressed */
+#define  M_COMMAND (1<<6) /* do command completion */
+#define  M_PATTERN (1<<7) /* pattern mode - only used for history classes */
+
+/* flags for mutt_get_token() */
+#define M_TOKEN_EQUAL		1	/* treat '=' as a special */
+#define M_TOKEN_CONDENSE	(1<<1)	/* ^(char) to control chars (macros) */
+#define M_TOKEN_SPACE		(1<<2)  /* don't treat whitespace as a term */
+#define M_TOKEN_QUOTE		(1<<3)	/* don't interpret quotes */
+#define M_TOKEN_PATTERN		(1<<4)	/* !)|~ are terms (for patterns) */
+#define M_TOKEN_COMMENT		(1<<5)	/* don't reap comments */
+#define M_TOKEN_SEMICOLON	(1<<6)	/* don't treat ; as special */
+
+/* flags for km_dokey() */
+#define M_KM_UNBUFFERED 1 /* don't read from the key buffer */
+
+typedef struct
+{
+  char *data;	/* pointer to data */
+  char *dptr;	/* current read/write position */
+  size_t dsize;	/* length of data */
+  int destroy;	/* destroy `data' when done? */
+} BUFFER;
+
+typedef struct
+{
+  int ch; /* raw key pressed */
+  int op; /* function op */
+} event_t;
+
+/* flags for _mutt_system() */
+#define M_DETACH_PROCESS	1	/* detach subprocess from group */
+
+/* flags for mutt_FormatString() */
+typedef enum
+{
+  M_FORMAT_FORCESUBJ	= (1<<0), /* print the subject even if unchanged */
+  M_FORMAT_TREE		= (1<<1), /* draw the thread tree */
+  M_FORMAT_MAKEPRINT	= (1<<2), /* make sure that all chars are printable */
+  M_FORMAT_OPTIONAL	= (1<<3),
+  M_FORMAT_STAT_FILE	= (1<<4), /* used by mutt_attach_fmt */
+  M_FORMAT_ARROWCURSOR	= (1<<5), /* reserve space for arrow_cursor */
+  M_FORMAT_INDEX	= (1<<6), /* this is a main index entry */
+  M_FORMAT_NOFILTER	= (1<<7)  /* do not allow filtering on this pass */
+} format_flag;
+
+/* types for mutt_add_hook() */
+#define M_FOLDERHOOK	1
+#define M_MBOXHOOK	(1<<1)
+#define M_SENDHOOK	(1<<2)
+#define M_FCCHOOK	(1<<3)
+#define M_SAVEHOOK	(1<<4)
+#define M_CHARSETHOOK	(1<<5)
+#define M_ICONVHOOK 	(1<<6)
+#define M_MESSAGEHOOK	(1<<7)
+#define M_CRYPTHOOK	(1<<8)
+#define M_ACCOUNTHOOK	(1<<9)
+#define M_REPLYHOOK	(1<<10)
+#define M_SEND2HOOK     (1<<11)
+
+/* tree characters for linearize_tree and print_enriched_string */
+#define M_TREE_LLCORNER		1
+#define M_TREE_ULCORNER		2
+#define M_TREE_LTEE		3
+#define M_TREE_HLINE		4
+#define M_TREE_VLINE		5
+#define M_TREE_SPACE		6
+#define M_TREE_RARROW		7
+#define M_TREE_STAR		8
+#define M_TREE_HIDDEN		9
+#define M_TREE_EQUALS		10
+#define M_TREE_TTEE		11
+#define M_TREE_BTEE		12
+#define M_TREE_MISSING		13
+#define M_TREE_MAX		14
+
+#define M_THREAD_COLLAPSE	(1<<0)
+#define M_THREAD_UNCOLLAPSE	(1<<1)
+#define M_THREAD_GET_HIDDEN	(1<<2)
+#define M_THREAD_UNREAD		(1<<3)
+#define M_THREAD_NEXT_UNREAD	(1<<4)
+
+enum
+{
+  /* modes for mutt_view_attachment() */
+  M_REGULAR = 1,
+  M_MAILCAP,
+  M_AS_TEXT,
+
+  /* action codes used by mutt_set_flag() and mutt_pattern_function() */
+  M_ALL,
+  M_NONE,
+  M_NEW,
+  M_OLD,
+  M_REPLIED,
+  M_READ,
+  M_UNREAD,
+  M_DELETE,
+  M_UNDELETE,
+  M_DELETED,
+  M_FLAG,
+  M_TAG,
+  M_UNTAG,
+  M_LIMIT,
+  M_EXPIRED,
+  M_SUPERSEDED,
+
+  /* actions for mutt_pattern_comp/mutt_pattern_exec */
+  M_AND,
+  M_OR,
+  M_THREAD,
+  M_TO,
+  M_CC,
+  M_COLLAPSED,
+  M_SUBJECT,
+  M_FROM,
+  M_DATE,
+  M_DATE_RECEIVED,
+  M_DUPLICATED,
+  M_UNREFERENCED,
+  M_ID,
+  M_BODY,
+  M_HEADER,
+  M_HORMEL,
+  M_WHOLE_MSG,
+  M_SENDER,
+  M_MESSAGE,
+  M_SCORE,
+  M_SIZE,
+  M_REFERENCE,
+  M_RECIPIENT,
+  M_LIST,
+  M_SUBSCRIBED_LIST,
+  M_PERSONAL_RECIP,
+  M_PERSONAL_FROM,
+  M_ADDRESS,
+  M_CRYPT_SIGN,
+  M_CRYPT_VERIFIED,
+  M_CRYPT_ENCRYPT,
+  M_PGP_KEY,
+  M_XLABEL,
+  M_MIMEATTACH,
+  
+  /* Options for Mailcap lookup */
+  M_EDIT,
+  M_COMPOSE,
+  M_PRINT,
+  M_AUTOVIEW,
+
+  /* options for socket code */
+  M_NEW_SOCKET,
+#ifdef USE_SSL_OPENSSL
+  M_NEW_SSL_SOCKET,
+#endif
+
+  /* Options for mutt_save_attachment */
+  M_SAVE_APPEND,
+  M_SAVE_OVERWRITE
+};
+
+/* possible arguments to set_quadoption() */
+enum
+{
+  M_NO,
+  M_YES,
+  M_ASKNO,
+  M_ASKYES
+};
+
+/* quad-option vars */
+enum
+{
+  OPT_ABORT,
+  OPT_BOUNCE,
+  OPT_COPY,
+  OPT_DELETE,
+  OPT_FORWEDIT,
+  OPT_FCCATTACH,
+  OPT_INCLUDE,
+  OPT_MFUPTO,
+  OPT_MIMEFWD,
+  OPT_MIMEFWDREST,
+  OPT_MOVE,
+  OPT_PGPMIMEAUTO,     /* ask to revert to PGP/MIME when inline fails */
+#ifdef USE_POP
+  OPT_POPDELETE,
+  OPT_POPRECONNECT,
+#endif
+  OPT_POSTPONE,
+  OPT_PRINT,
+  OPT_QUIT,
+  OPT_REPLYTO,
+  OPT_RECALL,
+#if defined(USE_SSL)
+  OPT_SSLSTARTTLS,
+#endif
+  OPT_SUBJECT,
+  OPT_VERIFYSIG,      /* verify PGP signatures */
+    
+  /* THIS MUST BE THE LAST VALUE. */
+  OPT_MAX
+};
+
+/* flags to ci_send_message() */
+#define SENDREPLY	(1<<0)
+#define SENDGROUPREPLY	(1<<1)
+#define SENDLISTREPLY	(1<<2)
+#define SENDFORWARD	(1<<3)
+#define SENDPOSTPONED	(1<<4)
+#define SENDBATCH	(1<<5)
+#define SENDMAILX	(1<<6)
+#define SENDKEY		(1<<7)
+#define SENDRESEND	(1<<8)
+#define SENDPOSTPONEDFCC	(1<<9) /* used by mutt_get_postponed() to signal that the x-mutt-fcc header field was present */
+
+/* flags to _mutt_select_file() */
+#define M_SEL_BUFFY	(1<<0)
+#define M_SEL_MULTI	(1<<1)
+#define M_SEL_FOLDER	(1<<2)
+
+/* flags for parse_spam_list */
+#define M_SPAM          1
+#define M_NOSPAM        2
+
+/* boolean vars */
+enum
+{
+  OPTALLOW8BIT,
+  OPTALLOWANSI,
+  OPTARROWCURSOR,
+  OPTASCIICHARS,
+  OPTASKBCC,
+  OPTASKCC,
+  OPTATTACHSPLIT,
+  OPTAUTOEDIT,
+  OPTAUTOTAG,
+  OPTBEEP,
+  OPTBEEPNEW,
+  OPTBOUNCEDELIVERED,
+  OPTBRAILLEFRIENDLY,
+  OPTCHECKMBOXSIZE,
+  OPTCHECKNEW,
+  OPTCOLLAPSEUNREAD,
+  OPTCONFIRMAPPEND,
+  OPTCONFIRMCREATE,
+  OPTDELETEUNTAG,
+  OPTDIGESTCOLLAPSE,
+  OPTDUPTHREADS,
+  OPTEDITHDRS,
+  OPTENCODEFROM,
+  OPTENVFROM,
+  OPTFASTREPLY,
+  OPTFCCCLEAR,
+  OPTFOLLOWUPTO,
+  OPTFORCENAME,
+  OPTFORWDECODE,
+  OPTFORWQUOTE,
+#ifdef USE_HCACHE
+  OPTHCACHEVERIFY,
+#if defined(HAVE_QDBM) || defined(HAVE_TC)
+  OPTHCACHECOMPRESS,
+#endif /* HAVE_QDBM */
+#endif
+  OPTHDRS,
+  OPTHEADER,
+  OPTHELP,
+  OPTHIDDENHOST,
+  OPTHIDELIMITED,
+  OPTHIDEMISSING,
+  OPTHIDETHREADSUBJECT,
+  OPTHIDETOPLIMITED,
+  OPTHIDETOPMISSING,
+  OPTHONORDISP,
+  OPTIGNORELWS,
+  OPTIGNORELISTREPLYTO,
+#ifdef USE_IMAP
+  OPTIMAPCHECKSUBSCRIBED,
+  OPTIMAPIDLE,
+  OPTIMAPLSUB,
+  OPTIMAPPASSIVE,
+  OPTIMAPPEEK,
+  OPTIMAPSERVERNOISE,
+#endif
+#if defined(USE_SSL)
+# ifndef USE_SSL_GNUTLS
+  OPTSSLSYSTEMCERTS,
+  OPTSSLV2,
+# endif /* USE_SSL_GNUTLS */
+  OPTSSLV3,
+  OPTTLSV1,
+  OPTTLSV1_1,
+  OPTTLSV1_2,
+  OPTSSLFORCETLS,
+  OPTSSLVERIFYDATES,
+  OPTSSLVERIFYHOST,
+#endif /* defined(USE_SSL) */
+  OPTIMPLICITAUTOVIEW,
+  OPTINCLUDEONLYFIRST,
+  OPTKEEPFLAGGED,
+  OPTMAILCAPSANITIZE,
+  OPTMAILCHECKRECENT,
+  OPTMAILDIRTRASH,
+  OPTMAILDIRCHECKCUR,
+  OPTMARKERS,
+  OPTMARKOLD,
+  OPTMENUSCROLL,	/* scroll menu instead of implicit next-page */
+  OPTMENUMOVEOFF,	/* allow menu to scroll past last entry */
+#if defined(USE_IMAP) || defined(USE_POP)
+  OPTMESSAGECACHECLEAN,
+#endif
+  OPTMETAKEY,		/* interpret ALT-x as ESC-x */
+  OPTMETOO,
+  OPTMHPURGE,
+  OPTMIMEFORWDECODE,
+  OPTNARROWTREE,
+  OPTPAGERSTOP,
+  OPTPIPEDECODE,
+  OPTPIPESPLIT,
+#ifdef USE_POP
+  OPTPOPAUTHTRYALL,
+  OPTPOPLAST,
+#endif
+  OPTPOSTPONEENCRYPT,
+  OPTPRINTDECODE,
+  OPTPRINTSPLIT,
+  OPTPROMPTAFTER,
+  OPTREADONLY,
+  OPTREFLOWTEXT,
+  OPTREPLYSELF,
+  OPTRESOLVE,
+  OPTREVALIAS,
+  OPTREVNAME,
+  OPTREVREAL,
+  OPTRFC2047PARAMS,
+  OPTSAVEADDRESS,
+  OPTSAVEEMPTY,
+  OPTSAVENAME,
+  OPTSCORE,
+  OPTSIGDASHES,
+  OPTSIGONTOP,
+  OPTSORTRE,
+  OPTSPAMSEP,
+  OPTSTATUSONTOP,
+  OPTSTRICTTHREADS,
+  OPTSUSPEND,
+  OPTTEXTFLOWED,
+  OPTTHOROUGHSRC,
+  OPTTHREADRECEIVED,
+  OPTTILDE,
+  OPTTSENABLED,
+  OPTUNCOLLAPSEJUMP,
+  OPTUSE8BITMIME,
+  OPTUSEDOMAIN,
+  OPTUSEFROM,
+  OPTUSEGPGAGENT,
+#ifdef HAVE_LIBIDN
+  OPTUSEIDN,
+#endif
+#ifdef HAVE_GETADDRINFO
+  OPTUSEIPV6,
+#endif
+  OPTWAITKEY,
+  OPTWEED,
+  OPTWRAP,
+  OPTWRAPSEARCH,
+  OPTWRITEBCC,		/* write out a bcc header? */
+  OPTXMAILER,
+
+  OPTCRYPTUSEGPGME,
+  OPTCRYPTUSEPKA,
+
+  /* PGP options */
+  
+  OPTCRYPTAUTOSIGN,
+  OPTCRYPTAUTOENCRYPT,
+  OPTCRYPTAUTOPGP,
+  OPTCRYPTAUTOSMIME,
+  OPTCRYPTCONFIRMHOOK,
+  OPTCRYPTOPPORTUNISTICENCRYPT,
+  OPTCRYPTREPLYENCRYPT,
+  OPTCRYPTREPLYSIGN,
+  OPTCRYPTREPLYSIGNENCRYPTED,
+  OPTCRYPTTIMESTAMP,
+  OPTSMIMEISDEFAULT,
+  OPTASKCERTLABEL,
+  OPTSDEFAULTDECRYPTKEY,
+  OPTPGPIGNORESUB,
+  OPTPGPCHECKEXIT,
+  OPTPGPLONGIDS,
+  OPTPGPAUTODEC,
+#if 0
+  OPTPGPENCRYPTSELF,
+#endif
+  OPTPGPRETAINABLESIG,
+  OPTPGPSTRICTENC,
+  OPTFORWDECRYPT,
+  OPTPGPSHOWUNUSABLE,
+  OPTPGPAUTOINLINE,
+  OPTPGPREPLYINLINE,
+
+  /* pseudo options */
+
+  OPTAUXSORT,		/* (pseudo) using auxiliary sort function */
+  OPTFORCEREFRESH,	/* (pseudo) refresh even during macros */
+  OPTLOCALES,		/* (pseudo) set if user has valid locale definition */
+  OPTNOCURSES,		/* (pseudo) when sending in batch mode */
+  OPTNEEDREDRAW,	/* (pseudo) to notify caller of a submenu */
+  OPTSEARCHREVERSE,	/* (pseudo) used by ci_search_command */
+  OPTMSGERR,		/* (pseudo) used by mutt_error/mutt_message */
+  OPTSEARCHINVALID,	/* (pseudo) used to invalidate the search pat */
+  OPTSIGNALSBLOCKED,	/* (pseudo) using by mutt_block_signals () */
+  OPTSYSSIGNALSBLOCKED,	/* (pseudo) using by mutt_block_signals_system () */
+  OPTNEEDRESORT,	/* (pseudo) used to force a re-sort */
+  OPTRESORTINIT,	/* (pseudo) used to force the next resort to be from scratch */
+  OPTVIEWATTACH,	/* (pseudo) signals that we are viewing attachments */
+  OPTFORCEREDRAWINDEX,	/* (pseudo) used to force a redraw in the main index */
+  OPTFORCEREDRAWPAGER,	/* (pseudo) used to force a redraw in the pager */
+  OPTSORTSUBTHREADS,	/* (pseudo) used when $sort_aux changes */
+  OPTNEEDRESCORE,	/* (pseudo) set when the `score' command is used */
+  OPTATTACHMSG,		/* (pseudo) used by attach-message */
+  OPTKEEPQUIET,		/* (pseudo) shut up the message and refresh
+			 * 	    functions while we are executing an
+			 * 	    external program.
+			 */
+  OPTMENUCALLER,	/* (pseudo) tell menu to give caller a take */
+  OPTREDRAWTREE,	/* (pseudo) redraw the thread tree */
+  OPTPGPCHECKTRUST,	/* (pseudo) used by pgp_select_key () */
+  OPTDONTHANDLEPGPKEYS,	/* (pseudo) used to extract PGP keys */
+  OPTUNBUFFEREDINPUT,   /* (pseudo) don't use key buffer */
+
+  OPTMAX
+};
+
+#define mutt_bit_alloc(n) calloc ((n + 7) / 8, sizeof (char))
+#define mutt_bit_set(v,n) v[n/8] |= (1 << (n % 8))
+#define mutt_bit_unset(v,n) v[n/8] &= ~(1 << (n % 8))
+#define mutt_bit_toggle(v,n) v[n/8] ^= (1 << (n % 8))
+#define mutt_bit_isset(v,n) (v[n/8] & (1 << (n % 8)))
+
+#define set_option(x) mutt_bit_set(Options,x)
+#define unset_option(x) mutt_bit_unset(Options,x)
+#define toggle_option(x) mutt_bit_toggle(Options,x)
+#define option(x) mutt_bit_isset(Options,x)
+
+typedef struct list_t
+{
+  char *data;
+  struct list_t *next;
+} LIST;
+
+typedef struct rx_list_t
+{
+  REGEXP *rx;
+  struct rx_list_t *next;
+} RX_LIST;
+
+typedef struct spam_list_t
+{
+  REGEXP *rx;
+  int     nmatch;
+  char   *template;
+  struct spam_list_t *next;
+} SPAM_LIST;
+
+#define mutt_new_list() safe_calloc (1, sizeof (LIST))
+#define mutt_new_rx_list() safe_calloc (1, sizeof (RX_LIST))
+#define mutt_new_spam_list() safe_calloc (1, sizeof (SPAM_LIST))
+void mutt_free_list (LIST **);
+void mutt_free_rx_list (RX_LIST **);
+void mutt_free_spam_list (SPAM_LIST **);
+LIST *mutt_copy_list (LIST *);
+int mutt_matches_ignore (const char *, LIST *);
+
+/* add an element to a list */
+LIST *mutt_add_list (LIST *, const char *);
+LIST *mutt_add_list_n (LIST*, const void *, size_t);
+LIST *mutt_find_list (LIST *, const char *);
+int mutt_remove_from_rx_list (RX_LIST **l, const char *str);
+
+void mutt_init (int, LIST *);
+
+typedef struct alias
+{
+  struct alias *self;		/* XXX - ugly hack */
+  char *name;
+  ADDRESS *addr;
+  struct alias *next;
+  short tagged;
+  short del;
+  short num;
+} ALIAS;
+
+typedef struct envelope
+{
+  ADDRESS *return_path;
+  ADDRESS *from;
+  ADDRESS *to;
+  ADDRESS *cc;
+  ADDRESS *bcc;
+  ADDRESS *sender;
+  ADDRESS *reply_to;
+  ADDRESS *mail_followup_to;
+  char *list_post;		/* this stores a mailto URL, or nothing */
+  char *subject;
+  char *real_subj;		/* offset of the real subject */
+  char *message_id;
+  char *supersedes;
+  char *date;
+  char *x_label;
+  BUFFER *spam;
+  LIST *references;		/* message references (in reverse order) */
+  LIST *in_reply_to;		/* in-reply-to header content */
+  LIST *userhdrs;		/* user defined headers */
+
+  unsigned int irt_changed : 1; /* In-Reply-To changed to link/break threads */
+  unsigned int refs_changed : 1; /* References changed to break thread */
+} ENVELOPE;
+
+typedef struct parameter
+{
+  char *attribute;
+  char *value;
+  struct parameter *next;
+} PARAMETER;
+
+/* Information that helps in determing the Content-* of an attachment */
+typedef struct content
+{
+  long hibin;              /* 8-bit characters */
+  long lobin;              /* unprintable 7-bit chars (eg., control chars) */
+  long crlf;		   /* '\r' and '\n' characters */
+  long ascii;              /* number of ascii chars */
+  long linemax;            /* length of the longest line in the file */
+  unsigned int space : 1;  /* whitespace at the end of lines? */
+  unsigned int binary : 1; /* long lines, or CR not in CRLF pair */
+  unsigned int from : 1;   /* has a line beginning with "From "? */
+  unsigned int dot : 1;    /* has a line consisting of a single dot? */
+  unsigned int cr : 1;     /* has CR, even when in a CRLF pair */
+} CONTENT;
+
+typedef struct body
+{
+  char *xtype;			/* content-type if x-unknown */
+  char *subtype;                /* content-type subtype */
+  PARAMETER *parameter;         /* parameters of the content-type */
+  char *description;            /* content-description */
+  char *form_name;		/* Content-Disposition form-data name param */
+  long hdr_offset;              /* offset in stream where the headers begin.
+				 * this info is used when invoking metamail,
+				 * where we need to send the headers of the
+				 * attachment
+				 */
+  LOFF_T offset;                /* offset where the actual data begins */
+  LOFF_T length;                /* length (in bytes) of attachment */
+  char *filename;               /* when sending a message, this is the file
+				 * to which this structure refers
+				 */
+  char *d_filename;		/* filename to be used for the 
+				 * content-disposition header.
+				 * If NULL, filename is used 
+				 * instead.
+				 */
+  char *charset;                /* charset of attached file */
+  CONTENT *content;             /* structure used to store detailed info about
+				 * the content of the attachment.  this is used
+				 * to determine what content-transfer-encoding
+				 * is required when sending mail.
+				 */
+  struct body *next;            /* next attachment in the list */
+  struct body *parts;           /* parts of a multipart or message/rfc822 */
+  struct header *hdr;		/* header information for message/rfc822 */
+
+  struct attachptr *aptr;	/* Menu information, used in recvattach.c */
+
+  signed short attach_count;
+
+  time_t stamp;			/* time stamp of last
+				 * encoding update.
+				 */
+  
+  unsigned int type : 4;        /* content-type primary type */
+  unsigned int encoding : 3;    /* content-transfer-encoding */
+  unsigned int disposition : 2; /* content-disposition */
+  unsigned int use_disp : 1;    /* Content-Disposition uses filename= ? */
+  unsigned int unlink : 1;      /* flag to indicate the the file named by
+				 * "filename" should be unlink()ed before
+				 * free()ing this structure
+				 */
+  unsigned int tagged : 1;
+  unsigned int deleted : 1;	/* attachment marked for deletion */
+
+  unsigned int noconv : 1;	/* don't do character set conversion */
+  unsigned int force_charset : 1; 
+  				/* send mode: don't adjust the character
+				 * set when in send-mode.
+				 */
+  unsigned int is_signed_data : 1; /* A lot of MUAs don't indicate
+                                      S/MIME signed-data correctly,
+                                      e.g. they use foo.p7m even for
+                                      the name of signed data.  This
+                                      flag is used to keep track of
+                                      the actual message type.  It
+                                      gets set during the verification
+                                      (which is done if the encryption
+                                      try failed) and check by the
+                                      function to figure the type of
+                                      the message. */
+
+  unsigned int goodsig : 1;	/* good cryptographic signature */
+  unsigned int warnsig : 1;     /* maybe good signature */
+  unsigned int badsig : 1;	/* bad cryptographic signature (needed to check encrypted s/mime-signatures) */
+
+  unsigned int collapsed : 1;	/* used by recvattach */
+  unsigned int attach_qualifies : 1;
+
+} BODY;
+
+/* #3279: AIX defines conflicting struct thread */
+typedef struct mutt_thread THREAD;
+
+typedef struct header
+{
+  unsigned int security : 12;  /* bit 0-8: flags, bit 9,10: application.
+				 see: mutt_crypt.h pgplib.h, smime.h */
+
+  unsigned int mime : 1;    		/* has a MIME-Version header? */
+  unsigned int flagged : 1; 		/* marked important? */
+  unsigned int tagged : 1;
+  unsigned int deleted : 1;
+  unsigned int changed : 1;
+  unsigned int attach_del : 1; 		/* has an attachment marked for deletion */
+  unsigned int old : 1;
+  unsigned int read : 1;
+  unsigned int expired : 1; 		/* already expired? */
+  unsigned int superseded : 1; 		/* got superseded? */
+  unsigned int replied : 1;
+  unsigned int subject_changed : 1; 	/* used for threading */
+  unsigned int threaded : 1;	    	/* used for threading */
+  unsigned int display_subject : 1; 	/* used for threading */
+  unsigned int recip_valid : 1;  	/* is_recipient is valid */
+  unsigned int active : 1;	    	/* message is not to be removed */
+  unsigned int trash : 1;		/* message is marked as trashed on disk.
+					 * This flag is used by the maildir_trash
+					 * option.
+					 */
+  
+  /* timezone of the sender of this message */
+  unsigned int zhours : 5;
+  unsigned int zminutes : 6;
+  unsigned int zoccident : 1;
+
+  /* bits used for caching when searching */
+  unsigned int searched : 1;
+  unsigned int matched : 1;
+
+  /* tells whether the attachment count is valid */
+  unsigned int attach_valid : 1;
+
+  /* the following are used to support collapsing threads  */
+  unsigned int collapsed : 1; 	/* is this message part of a collapsed thread? */
+  unsigned int limited : 1;   	/* is this message in a limited view?  */
+  size_t num_hidden;          	/* number of hidden messages in this view */
+
+  short recipient;		/* user_is_recipient()'s return value, cached */
+  
+  int pair; 			/* color-pair to use when displaying in the index */
+
+  time_t date_sent;     	/* time when the message was sent (UTC) */
+  time_t received;      	/* time when the message was placed in the mailbox */
+  LOFF_T offset;          	/* where in the stream does this message begin? */
+  int lines;			/* how many lines in the body of this message? */
+  int index;			/* the absolute (unsorted) message number */
+  int msgno;			/* number displayed to the user */
+  int virtual;			/* virtual message number */
+  int score;
+  ENVELOPE *env;		/* envelope information */
+  BODY *content;		/* list of MIME parts */
+  char *path;
+  
+  char *tree;           	/* character string to print thread tree */
+  THREAD *thread;
+
+  /* Number of qualifying attachments in message, if attach_valid */
+  short attach_total;
+
+#ifdef MIXMASTER
+  LIST *chain;
+#endif
+
+#ifdef USE_POP
+  int refno;			/* message number on server */
+#endif
+
+#if defined USE_POP || defined USE_IMAP
+  void *data;            	/* driver-specific data */
+#endif
+  
+  char *maildir_flags;		/* unknown maildir flags */
+} HEADER;
+
+struct mutt_thread
+{
+  unsigned int fake_thread : 1;
+  unsigned int duplicate_thread : 1;
+  unsigned int sort_children : 1;
+  unsigned int check_subject : 1;
+  unsigned int visible : 1;
+  unsigned int deep : 1;
+  unsigned int subtree_visible : 2;
+  unsigned int next_subtree_visible : 1;
+  THREAD *parent;
+  THREAD *child;
+  THREAD *next;
+  THREAD *prev;
+  HEADER *message;
+  HEADER *sort_key;
+};
+
+
+/* flag to mutt_pattern_comp() */
+#define M_FULL_MSG	(1<<0)	/* enable body and header matching */
+
+typedef enum {
+  M_MATCH_FULL_ADDRESS = 1
+} pattern_exec_flag;
+
+typedef struct group_t
+{
+  ADDRESS *as;
+  RX_LIST *rs;
+  char *name;
+} group_t;
+
+typedef struct group_context_t
+{
+  group_t *g;
+  struct group_context_t *next;
+} group_context_t;
+
+typedef struct pattern_t
+{
+  short op;
+  unsigned int not : 1;
+  unsigned int alladdr : 1;
+  unsigned int stringmatch : 1;
+  unsigned int groupmatch : 1;
+  unsigned int ign_case : 1;		/* ignore case for local stringmatch searches */
+  int min;
+  int max;
+  struct pattern_t *next;
+  struct pattern_t *child;		/* arguments to logical op */
+  union 
+  {
+    regex_t *rx;
+    group_t *g;
+    char *str;
+  } p;
+} pattern_t;
+
+/* ACL Rights */
+enum
+{
+  M_ACL_LOOKUP = 0,
+  M_ACL_READ,
+  M_ACL_SEEN,
+  M_ACL_WRITE,
+  M_ACL_INSERT,
+  M_ACL_POST,
+  M_ACL_CREATE,
+  M_ACL_DELMX,
+  M_ACL_DELETE,
+  M_ACL_EXPUNGE,
+  M_ACL_ADMIN,
+
+  RIGHTSMAX
+};
+
+typedef struct _context
+{
+  char *path;
+  FILE *fp;
+  time_t mtime;
+  off_t size;
+  off_t vsize;
+  char *pattern;                /* limit pattern string */
+  pattern_t *limit_pattern;     /* compiled limit pattern */
+  HEADER **hdrs;
+  HEADER *last_tag;		/* last tagged msg. used to link threads */
+  THREAD *tree;			/* top of thread tree */
+  HASH *id_hash;		/* hash table by msg id */
+  HASH *subj_hash;		/* hash table by subject */
+  HASH *thread_hash;		/* hash table for threading */
+  int *v2r;			/* mapping from virtual to real msgno */
+  int hdrmax;			/* number of pointers in hdrs */
+  int msgcount;			/* number of messages in the mailbox */
+  int vcount;			/* the number of virtual messages */
+  int tagged;			/* how many messages are tagged? */
+  int new;			/* how many new messages? */
+  int unread;			/* how many unread messages? */
+  int deleted;			/* how many deleted messages */
+  int flagged;			/* how many flagged messages */
+  int msgnotreadyet;		/* which msg "new" in pager, -1 if none */
+
+  short magic;			/* mailbox type */
+
+  unsigned char rights[(RIGHTSMAX + 7)/8];	/* ACL bits */
+
+  unsigned int locked : 1;	/* is the mailbox locked? */
+  unsigned int changed : 1;	/* mailbox has been modified */
+  unsigned int readonly : 1;    /* don't allow changes to the mailbox */
+  unsigned int dontwrite : 1;   /* don't write the mailbox on close */
+  unsigned int append : 1;	/* mailbox is opened in append mode */
+  unsigned int quiet : 1;	/* inhibit status messages? */
+  unsigned int collapsed : 1;   /* are all threads collapsed? */
+  unsigned int closing : 1;	/* mailbox is being closed */
+
+  /* driver hooks */
+  void *data;			/* driver specific data */
+  int (*mx_close)(struct _context *);
+} CONTEXT;
+
+typedef struct
+{
+  FILE *fpin;
+  FILE *fpout;
+  char *prefix;
+  int flags;
+} STATE;
+
+/* used by enter.c */
+
+typedef struct
+{
+  wchar_t *wbuf;
+  size_t wbuflen;
+  size_t lastchar;
+  size_t curpos;
+  size_t begin;
+  int	 tabs;
+} ENTER_STATE;
+
+/* flags for the STATE struct */
+#define M_DISPLAY	(1<<0) /* output is displayed to the user */
+#define M_VERIFY	(1<<1) /* perform signature verification */
+#define M_PENDINGPREFIX (1<<2) /* prefix to write, but character must follow */
+#define M_WEED          (1<<3) /* weed headers even when not in display mode */
+#define M_CHARCONV	(1<<4) /* Do character set conversions */
+#define M_PRINTING	(1<<5) /* are we printing? - M_DISPLAY "light" */
+#define M_REPLYING	(1<<6) /* are we replying? */
+#define M_FIRSTDONE	(1<<7) /* the first attachment has been done */
+
+#define state_set_prefix(s) ((s)->flags |= M_PENDINGPREFIX)
+#define state_reset_prefix(s) ((s)->flags &= ~M_PENDINGPREFIX)
+#define state_puts(x,y) fputs(x,(y)->fpout)
+#define state_putc(x,y) fputc(x,(y)->fpout)
+
+void state_mark_attach (STATE *);
+void state_attach_puts (const char *, STATE *);
+void state_prefix_putc (char, STATE *);
+int  state_printf(STATE *, const char *, ...);
+int state_putwc (wchar_t, STATE *);
+int state_putws (const wchar_t *, STATE *);
+
+/* for attachment counter */
+typedef struct
+{
+  char   *major;
+  int     major_int;
+  char   *minor;
+  regex_t minor_rx;
+} ATTACH_MATCH;
+
+#define M_PARTS_TOPLEVEL	(1<<0)	/* is the top-level part */
+
+#include "ascii.h"
+#include "protos.h"
+#include "lib.h"
+#include "globals.h"
+
+#endif /*MUTT_H*/
diff -uNp -r mutt.b/muttlib.c mutt.a/muttlib.c
--- mutt.b/muttlib.c	2015-09-23 10:26:44.000000000 +0200
+++ mutt.a/muttlib.c	2015-09-23 10:28:45.000000000 +0200
@@ -1505,7 +1505,9 @@ int mutt_save_confirm (const char *s, st
 
   if (magic > 0 && !mx_access (s, W_OK))
   {
-    if (option (OPTCONFIRMAPPEND))
+    if (option (OPTCONFIRMAPPEND) &&
+       (!TrashPath || (mutt_strcmp (s, TrashPath) != 0)))
+      /* if we're appending to the trash, there's no point in asking */
     {
       snprintf (tmp, sizeof (tmp), _("Append messages to %s?"), s);
       if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
diff -uNp -r mutt.b/muttlib.c.orig mutt.a/muttlib.c.orig
--- mutt.b/muttlib.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mutt.a/muttlib.c.orig	2015-09-23 10:26:44.000000000 +0200
@@ -0,0 +1,1951 @@
+/*
+ * Copyright (C) 1996-2000,2007 Michael R. Elkins <me@mutt.org>
+ * Copyright (C) 1999-2008 Thomas Roessler <roessler@does-not-exist.org>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */ 
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_curses.h"
+#include "mime.h"
+#include "mailbox.h"
+#include "mx.h"
+#include "url.h"
+
+#ifdef USE_IMAP
+#include "imap.h"
+#endif
+
+#include "mutt_crypt.h"
+
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/types.h>
+#include <utime.h>
+
+BODY *mutt_new_body (void)
+{
+  BODY *p = (BODY *) safe_calloc (1, sizeof (BODY));
+    
+  p->disposition = DISPATTACH;
+  p->use_disp = 1;
+  return (p);
+}
+
+
+/* Modified by blong to accept a "suggestion" for file name.  If
+ * that file exists, then construct one with unique name but 
+ * keep any extension.  This might fail, I guess.
+ * Renamed to mutt_adv_mktemp so I only have to change where it's
+ * called, and not all possible cases.
+ */
+void mutt_adv_mktemp (char *s, size_t l)
+{
+  char prefix[_POSIX_PATH_MAX];
+  char *suffix;
+  struct stat sb;
+
+  if (s[0] == '\0')
+  {
+    mutt_mktemp (s, l);
+  }
+  else
+  {
+    strfcpy (prefix, s, sizeof (prefix));
+    mutt_sanitize_filename (prefix, 1);
+    snprintf (s, l, "%s/%s", NONULL (Tempdir), prefix);
+    if (lstat (s, &sb) == -1 && errno == ENOENT)
+      return;
+
+    if ((suffix = strrchr (prefix, '.')) != NULL)
+    {
+      *suffix = 0;
+      ++suffix;
+    }
+    mutt_mktemp_pfx_sfx (s, l, prefix, suffix);
+  }
+}
+
+/* create a send-mode duplicate from a receive-mode body */
+
+int mutt_copy_body (FILE *fp, BODY **tgt, BODY *src)
+{
+  char tmp[_POSIX_PATH_MAX];
+  BODY *b;
+
+  PARAMETER *par, **ppar;
+  
+  short use_disp;
+
+  if (src->filename)
+  {
+    use_disp = 1;
+    strfcpy (tmp, src->filename, sizeof (tmp));
+  }
+  else
+  {
+    use_disp = 0;
+    tmp[0] = '\0';
+  }
+
+  mutt_adv_mktemp (tmp, sizeof (tmp));
+  if (mutt_save_attachment (fp, src, tmp, 0, NULL) == -1)
+    return -1;
+      
+  *tgt = mutt_new_body ();
+  b = *tgt;
+
+  memcpy (b, src, sizeof (BODY));
+  b->parts = NULL;
+  b->next  = NULL;
+
+  b->filename = safe_strdup (tmp);
+  b->use_disp = use_disp;
+  b->unlink = 1;
+
+  if (mutt_is_text_part (b))
+    b->noconv = 1;
+
+  b->xtype = safe_strdup (b->xtype);
+  b->subtype = safe_strdup (b->subtype);
+  b->form_name = safe_strdup (b->form_name);
+  b->filename = safe_strdup (b->filename);
+  b->d_filename = safe_strdup (b->d_filename);
+  b->description = safe_strdup (b->description);
+
+  /* 
+   * we don't seem to need the HEADER structure currently.
+   * XXX - this may change in the future
+   */
+
+  if (b->hdr) b->hdr = NULL;
+  
+  /* copy parameters */
+  for (par = b->parameter, ppar = &b->parameter; par; ppar = &(*ppar)->next, par = par->next)
+  {
+    *ppar = mutt_new_parameter ();
+    (*ppar)->attribute = safe_strdup (par->attribute);
+    (*ppar)->value = safe_strdup (par->value);
+  }
+
+  mutt_stamp_attachment (b);
+  
+  return 0;
+}
+
+
+
+void mutt_free_body (BODY **p)
+{
+  BODY *a = *p, *b;
+
+  while (a)
+  {
+    b = a;
+    a = a->next; 
+
+    if (b->parameter)
+      mutt_free_parameter (&b->parameter);
+    if (b->filename)
+    {
+      if (b->unlink)
+	unlink (b->filename);
+      dprint (1, (debugfile, "mutt_free_body: %sunlinking %s.\n",
+	    b->unlink ? "" : "not ", b->filename));
+    }
+
+    FREE (&b->filename);
+    FREE (&b->content);
+    FREE (&b->xtype);
+    FREE (&b->subtype);
+    FREE (&b->description);
+    FREE (&b->form_name);
+
+    if (b->hdr)
+    {
+      /* Don't free twice (b->hdr->content = b->parts) */
+      b->hdr->content = NULL;
+      mutt_free_header(&b->hdr);
+    }
+
+    if (b->parts)
+      mutt_free_body (&b->parts);
+
+    FREE (&b);
+  }
+
+  *p = 0;
+}
+
+void mutt_free_parameter (PARAMETER **p)
+{
+  PARAMETER *t = *p;
+  PARAMETER *o;
+
+  while (t)
+  {
+    FREE (&t->attribute);
+    FREE (&t->value);
+    o = t;
+    t = t->next;
+    FREE (&o);
+  }
+  *p = 0;
+}
+
+LIST *mutt_add_list (LIST *head, const char *data)
+{
+  size_t len = mutt_strlen (data);
+
+  return mutt_add_list_n (head, data, len ? len + 1 : 0);
+}
+
+LIST *mutt_add_list_n (LIST *head, const void *data, size_t len)
+{
+  LIST *tmp;
+  
+  for (tmp = head; tmp && tmp->next; tmp = tmp->next)
+    ;
+  if (tmp)
+  {
+    tmp->next = safe_malloc (sizeof (LIST));
+    tmp = tmp->next;
+  }
+  else
+    head = tmp = safe_malloc (sizeof (LIST));
+  
+  tmp->data = safe_malloc (len);
+  if (len)
+    memcpy (tmp->data, data, len);
+  tmp->next = NULL;
+  return head;
+}
+
+LIST *mutt_find_list (LIST *l, const char *data)
+{
+  LIST *p = l;
+
+  while (p)
+  {
+    if (data == p->data)
+      return p;
+    if (data && p->data && mutt_strcmp (p->data, data) == 0)
+      return p;
+    p = p->next;
+  }
+  return NULL;
+}
+
+int mutt_remove_from_rx_list (RX_LIST **l, const char *str)
+{
+  RX_LIST *p, *last = NULL;
+  int rv = -1;
+
+  if (mutt_strcmp ("*", str) == 0)
+  {
+    mutt_free_rx_list (l);    /* ``unCMD *'' means delete all current entries */
+    rv = 0;
+  }
+  else
+  {
+    p = *l;
+    last = NULL;
+    while (p)
+    {
+      if (ascii_strcasecmp (str, p->rx->pattern) == 0)
+      {
+	mutt_free_regexp (&p->rx);
+	if (last)
+	  last->next = p->next;
+	else
+	  (*l) = p->next;
+	FREE (&p);
+	rv = 0;
+      }
+      else
+      {
+	last = p;
+	p = p->next;
+      }
+    }
+  }
+  return (rv);
+}
+
+void mutt_free_list (LIST **list)
+{
+  LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    FREE (&p->data);
+    FREE (&p);
+  }
+}
+
+HEADER *mutt_dup_header(HEADER *h)
+{
+  HEADER *hnew;
+
+  hnew = mutt_new_header();
+  memcpy(hnew, h, sizeof (HEADER));
+  return hnew;
+}
+
+void mutt_free_header (HEADER **h)
+{
+  if(!h || !*h) return;
+  mutt_free_envelope (&(*h)->env);
+  mutt_free_body (&(*h)->content);
+  FREE (&(*h)->maildir_flags);
+  FREE (&(*h)->tree);
+  FREE (&(*h)->path);
+#ifdef MIXMASTER
+  mutt_free_list (&(*h)->chain);
+#endif
+#if defined USE_POP || defined USE_IMAP
+  FREE (&(*h)->data);
+#endif
+  FREE (h);		/* __FREE_CHECKED__ */
+}
+
+/* returns true if the header contained in "s" is in list "t" */
+int mutt_matches_ignore (const char *s, LIST *t)
+{
+  for (; t; t = t->next)
+  {
+    if (!ascii_strncasecmp (s, t->data, mutt_strlen (t->data)) || *t->data == '*')
+      return 1;
+  }
+  return 0;
+}
+
+/* prepend the path part of *path to *link */
+void mutt_expand_link (char *newpath, const char *path, const char *link)
+{
+  const char *lb = NULL;
+  size_t len;
+
+  /* link is full path */
+  if (*link == '/')
+  {
+    strfcpy (newpath, link, _POSIX_PATH_MAX);
+    return;
+  }
+
+  if ((lb = strrchr (path, '/')) == NULL)
+  {
+    /* no path in link */
+    strfcpy (newpath, link, _POSIX_PATH_MAX);
+    return;
+  }
+
+  len = lb - path + 1;
+  memcpy (newpath, path, len);
+  strfcpy (newpath + len, link, _POSIX_PATH_MAX - len);
+}
+
+char *mutt_expand_path (char *s, size_t slen)
+{
+  return _mutt_expand_path (s, slen, 0);
+}
+
+char *_mutt_expand_path (char *s, size_t slen, int rx)
+{
+  char p[_POSIX_PATH_MAX] = "";
+  char q[_POSIX_PATH_MAX] = "";
+  char tmp[_POSIX_PATH_MAX];
+  char *t;
+
+  char *tail = ""; 
+
+  int recurse = 0;
+  
+  do 
+  {
+    recurse = 0;
+
+    switch (*s)
+    {
+      case '~':
+      {
+	if (*(s + 1) == '/' || *(s + 1) == 0)
+	{
+	  strfcpy (p, NONULL(Homedir), sizeof (p));
+	  tail = s + 1;
+	}
+	else
+	{
+	  struct passwd *pw;
+	  if ((t = strchr (s + 1, '/'))) 
+	    *t = 0;
+
+	  if ((pw = getpwnam (s + 1)))
+	  {
+	    strfcpy (p, pw->pw_dir, sizeof (p));
+	    if (t)
+	    {
+	      *t = '/';
+	      tail = t;
+	    }
+	    else
+	      tail = "";
+	  }
+	  else
+	  {
+	    /* user not found! */
+	    if (t)
+	      *t = '/';
+	    *p = '\0';
+	    tail = s;
+	  }
+	}
+      }
+      break;
+      
+      case '=':
+      case '+':    
+      {
+#ifdef USE_IMAP
+	/* if folder = {host} or imap[s]://host/: don't append slash */
+	if (mx_is_imap (NONULL (Maildir)) &&
+	    (Maildir[strlen (Maildir) - 1] == '}' ||
+	     Maildir[strlen (Maildir) - 1] == '/'))
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+#endif
+	if (Maildir && *Maildir && Maildir[strlen (Maildir) - 1] == '/')
+	  strfcpy (p, NONULL (Maildir), sizeof (p));
+	else
+	  snprintf (p, sizeof (p), "%s/", NONULL (Maildir));
+	
+	tail = s + 1;
+      }
+      break;
+      
+      /* elm compatibility, @ expands alias to user name */
+    
+      case '@':
+      {
+	HEADER *h;
+	ADDRESS *alias;
+	
+	if ((alias = mutt_lookup_alias (s + 1)))
+	{
+	  h = mutt_new_header();
+	  h->env = mutt_new_envelope();
+	  h->env->from = h->env->to = alias;
+	  mutt_default_save (p, sizeof (p), h);
+	  h->env->from = h->env->to = NULL;
+	  mutt_free_header (&h);
+	  /* Avoid infinite recursion if the resulting folder starts with '@' */
+	  if (*p != '@')
+	    recurse = 1;
+	  
+	  tail = "";
+	}
+      }
+      break;
+      
+      case '>':
+      {
+	strfcpy (p, NONULL(Inbox), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '<':
+      {
+	strfcpy (p, NONULL(Outbox), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '!':
+      {
+	if (*(s+1) == '!')
+	{
+	  strfcpy (p, NONULL(LastFolder), sizeof (p));
+	  tail = s + 2;
+	}
+	else 
+	{
+	  strfcpy (p, NONULL(Spoolfile), sizeof (p));
+	  tail = s + 1;
+	}
+      }
+      break;
+      
+      case '-':
+      {
+	strfcpy (p, NONULL(LastFolder), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+      
+      case '^':        
+      {
+	strfcpy (p, NONULL(CurrentFolder), sizeof (p));
+	tail = s + 1;
+      }
+      break;
+
+      default:
+      {
+	*p = '\0';
+	tail = s;
+      }
+    }
+
+    if (rx && *p && !recurse)
+    {
+      mutt_rx_sanitize_string (q, sizeof (q), p);
+      snprintf (tmp, sizeof (tmp), "%s%s", q, tail);
+    }
+    else
+      snprintf (tmp, sizeof (tmp), "%s%s", p, tail);
+    
+    strfcpy (s, tmp, slen);
+  }
+  while (recurse);
+
+#ifdef USE_IMAP
+  /* Rewrite IMAP path in canonical form - aids in string comparisons of
+   * folders. May possibly fail, in which case s should be the same. */
+  if (mx_is_imap (s))
+    imap_expand_path (s, slen);
+#endif
+
+  return (s);
+}
+
+/* Extract the real name from /etc/passwd's GECOS field.
+ * When set, honor the regular expression in GecosMask,
+ * otherwise assume that the GECOS field is a 
+ * comma-separated list.
+ * Replace "&" by a capitalized version of the user's login
+ * name.
+ */
+
+char *mutt_gecos_name (char *dest, size_t destlen, struct passwd *pw)
+{
+  regmatch_t pat_match[1];
+  size_t pwnl;
+  int idx;
+  char *p;
+  
+  if (!pw || !pw->pw_gecos) 
+    return NULL;
+
+  memset (dest, 0, destlen);
+  
+  if (GecosMask.rx)
+  {
+    if (regexec (GecosMask.rx, pw->pw_gecos, 1, pat_match, 0) == 0)
+      strfcpy (dest, pw->pw_gecos + pat_match[0].rm_so, 
+	       MIN (pat_match[0].rm_eo - pat_match[0].rm_so + 1, destlen));
+  }
+  else if ((p = strchr (pw->pw_gecos, ',')))
+    strfcpy (dest, pw->pw_gecos, MIN (destlen, p - pw->pw_gecos + 1));
+  else
+    strfcpy (dest, pw->pw_gecos, destlen);
+
+  pwnl = strlen (pw->pw_name);
+
+  for (idx = 0; dest[idx]; idx++)
+  {
+    if (dest[idx] == '&')
+    {
+      memmove (&dest[idx + pwnl], &dest[idx + 1],
+	       MAX((ssize_t)(destlen - idx - pwnl - 1), 0));
+      memcpy (&dest[idx], pw->pw_name, MIN(destlen - idx - 1, pwnl));
+      dest[idx] = toupper ((unsigned char) dest[idx]);
+    }
+  }
+      
+  return dest;
+}
+  
+
+char *mutt_get_parameter (const char *s, PARAMETER *p)
+{
+  for (; p; p = p->next)
+    if (ascii_strcasecmp (s, p->attribute) == 0)
+      return (p->value);
+
+  return NULL;
+}
+
+void mutt_set_parameter (const char *attribute, const char *value, PARAMETER **p)
+{
+  PARAMETER *q;
+
+  if (!value)
+  {
+    mutt_delete_parameter (attribute, p);
+    return;
+  }
+  
+  for(q = *p; q; q = q->next)
+  {
+    if (ascii_strcasecmp (attribute, q->attribute) == 0)
+    {
+      mutt_str_replace (&q->value, value);
+      return;
+    }
+  }
+  
+  q = mutt_new_parameter();
+  q->attribute = safe_strdup(attribute);
+  q->value = safe_strdup(value);
+  q->next = *p;
+  *p = q;
+}
+
+void mutt_delete_parameter (const char *attribute, PARAMETER **p)
+{
+  PARAMETER *q;
+  
+  for (q = *p; q; p = &q->next, q = q->next)
+  {
+    if (ascii_strcasecmp (attribute, q->attribute) == 0)
+    {
+      *p = q->next;
+      q->next = NULL;
+      mutt_free_parameter (&q);
+      return;
+    }
+  }
+}
+
+/* returns 1 if Mutt can't display this type of data, 0 otherwise */
+int mutt_needs_mailcap (BODY *m)
+{
+  switch (m->type)
+  {
+    case TYPETEXT:
+      /* we can display any text, overridable by auto_view */
+      return 0;
+      break;
+
+    case TYPEAPPLICATION:
+      if((WithCrypto & APPLICATION_PGP) && mutt_is_application_pgp(m))
+	return 0;
+      if((WithCrypto & APPLICATION_SMIME) && mutt_is_application_smime(m))
+	return 0;
+      break;
+
+    case TYPEMULTIPART:
+    case TYPEMESSAGE:
+      return 0;
+  }
+
+  return 1;
+}
+
+int mutt_is_text_part (BODY *b)
+{
+  int t = b->type;
+  char *s = b->subtype;
+  
+  if ((WithCrypto & APPLICATION_PGP) && mutt_is_application_pgp (b))
+    return 0;
+
+  if (t == TYPETEXT)
+    return 1;
+
+  if (t == TYPEMESSAGE)
+  {
+    if (!ascii_strcasecmp ("delivery-status", s))
+      return 1;
+  }
+
+  if ((WithCrypto & APPLICATION_PGP) && t == TYPEAPPLICATION)
+  {
+    if (!ascii_strcasecmp ("pgp-keys", s))
+      return 1;
+  }
+
+  return 0;
+}
+
+void mutt_free_envelope (ENVELOPE **p)
+{
+  if (!*p) return;
+  rfc822_free_address (&(*p)->return_path);
+  rfc822_free_address (&(*p)->from);
+  rfc822_free_address (&(*p)->to);
+  rfc822_free_address (&(*p)->cc);
+  rfc822_free_address (&(*p)->bcc);
+  rfc822_free_address (&(*p)->sender);
+  rfc822_free_address (&(*p)->reply_to);
+  rfc822_free_address (&(*p)->mail_followup_to);
+
+  FREE (&(*p)->list_post);
+  FREE (&(*p)->subject);
+  /* real_subj is just an offset to subject and shouldn't be freed */
+  FREE (&(*p)->message_id);
+  FREE (&(*p)->supersedes);
+  FREE (&(*p)->date);
+  FREE (&(*p)->x_label);
+
+  mutt_buffer_free (&(*p)->spam);
+
+  mutt_free_list (&(*p)->references);
+  mutt_free_list (&(*p)->in_reply_to);
+  mutt_free_list (&(*p)->userhdrs);
+  FREE (p);		/* __FREE_CHECKED__ */
+}
+
+/* move all the headers from extra not present in base into base */
+void mutt_merge_envelopes(ENVELOPE* base, ENVELOPE** extra)
+{
+  /* copies each existing element if necessary, and sets the element
+  * to NULL in the source so that mutt_free_envelope doesn't leave us
+  * with dangling pointers. */
+#define MOVE_ELEM(h) if (!base->h) { base->h = (*extra)->h; (*extra)->h = NULL; }
+  MOVE_ELEM(return_path);
+  MOVE_ELEM(from);
+  MOVE_ELEM(to);
+  MOVE_ELEM(cc);
+  MOVE_ELEM(bcc);
+  MOVE_ELEM(sender);
+  MOVE_ELEM(reply_to);
+  MOVE_ELEM(mail_followup_to);
+  MOVE_ELEM(list_post);
+  MOVE_ELEM(message_id);
+  MOVE_ELEM(supersedes);
+  MOVE_ELEM(date);
+  MOVE_ELEM(x_label);
+  if (!base->refs_changed)
+  {
+    MOVE_ELEM(references);
+  }
+  if (!base->irt_changed)
+  {
+    MOVE_ELEM(in_reply_to);
+  }
+  
+  /* real_subj is subordinate to subject */
+  if (!base->subject)
+  {
+    base->subject = (*extra)->subject;
+    base->real_subj = (*extra)->real_subj;
+    (*extra)->subject = NULL;
+    (*extra)->real_subj = NULL;
+  }
+  /* spam and user headers should never be hashed, and the new envelope may
+    * have better values. Use new versions regardless. */
+  mutt_buffer_free (&base->spam);
+  mutt_free_list (&base->userhdrs);
+  MOVE_ELEM(spam);
+  MOVE_ELEM(userhdrs);
+#undef MOVE_ELEM
+  
+  mutt_free_envelope(extra);
+}
+
+void _mutt_mktemp (char *s, size_t slen, const char *prefix, const char *suffix,
+                   const char *src, int line)
+{
+  size_t n = snprintf (s, slen, "%s/%s-%s-%d-%d-%ld%ld%s%s",
+      NONULL (Tempdir), NONULL (prefix), NONULL (Hostname),
+      (int) getuid (), (int) getpid (), random (), random (),
+      suffix ? "." : "", NONULL (suffix));
+  if (n >= slen)
+    dprint (1, (debugfile, "%s:%d: ERROR: insufficient buffer space to hold temporary filename! slen=%zu but need %zu\n",
+	    src, line, slen, n));
+  dprint (3, (debugfile, "%s:%d: mutt_mktemp returns \"%s\".\n", src, line, s));
+  if (unlink (s) && errno != ENOENT)
+    dprint (1, (debugfile, "%s:%d: ERROR: unlink(\"%s\"): %s (errno %d)\n", src, line, s, strerror (errno), errno));
+}
+
+void mutt_free_alias (ALIAS **p)
+{
+  ALIAS *t;
+
+  while (*p)
+  {
+    t = *p;
+    *p = (*p)->next;
+    mutt_alias_delete_reverse (t);
+    FREE (&t->name);
+    rfc822_free_address (&t->addr);
+    FREE (&t);
+  }
+}
+
+/* collapse the pathname using ~ or = when possible */
+void mutt_pretty_mailbox (char *s, size_t buflen)
+{
+  char *p = s, *q = s;
+  size_t len;
+  url_scheme_t scheme;
+  char tmp[PATH_MAX];
+
+  scheme = url_check_scheme (s);
+
+#ifdef USE_IMAP
+  if (scheme == U_IMAP || scheme == U_IMAPS)
+  {
+    imap_pretty_mailbox (s);
+    return;
+  }
+#endif
+
+  /* if s is an url, only collapse path component */
+  if (scheme != U_UNKNOWN)
+  {
+    p = strchr(s, ':')+1;
+    if (!strncmp (p, "//", 2))
+      q = strchr (p+2, '/');
+    if (!q)
+      q = strchr (p, '\0');
+    p = q;
+  }
+
+  /* cleanup path */
+  if (strstr (p, "//") || strstr (p, "/./"))
+  {
+    /* first attempt to collapse the pathname, this is more
+     * lightweight than realpath() and doesn't resolve links
+     */
+    while (*p)
+    {
+      if (*p == '/' && p[1] == '/')
+      {
+	*q++ = '/';
+	p += 2;
+      }
+      else if (p[0] == '/' && p[1] == '.' && p[2] == '/')
+      {
+	*q++ = '/';
+	p += 3;
+      }
+      else
+	*q++ = *p++;
+    }
+    *q = 0;
+  }
+  else if (strstr (p, "..") && 
+	   (scheme == U_UNKNOWN || scheme == U_FILE) &&
+	   realpath (p, tmp))
+    strfcpy (p, tmp, buflen - (p - s));
+
+  if (mutt_strncmp (s, Maildir, (len = mutt_strlen (Maildir))) == 0 &&
+      s[len] == '/')
+  {
+    *s++ = '=';
+    memmove (s, s + len, mutt_strlen (s + len) + 1);
+  }
+  else if (mutt_strncmp (s, Homedir, (len = mutt_strlen (Homedir))) == 0 &&
+	   s[len] == '/')
+  {
+    *s++ = '~';
+    memmove (s, s + len - 1, mutt_strlen (s + len - 1) + 1);
+  }
+}
+
+void mutt_pretty_size (char *s, size_t len, LOFF_T n)
+{
+  if (n == 0)
+    strfcpy (s, "0K", len);
+  else if (n < 10189) /* 0.1K - 9.9K */
+    snprintf (s, len, "%3.1fK", (n < 103) ? 0.1 : n / 1024.0);
+  else if (n < 1023949) /* 10K - 999K */
+  {
+    /* 51 is magic which causes 10189/10240 to be rounded up to 10 */
+    snprintf (s, len, OFF_T_FMT "K", (n + 51) / 1024);
+  }
+  else if (n < 10433332) /* 1.0M - 9.9M */
+    snprintf (s, len, "%3.1fM", n / 1048576.0);
+  else /* 10M+ */
+  {
+    /* (10433332 + 52428) / 1048576 = 10 */
+    snprintf (s, len, OFF_T_FMT "M", (n + 52428) / 1048576);
+  }
+}
+
+void mutt_expand_file_fmt (char *dest, size_t destlen, const char *fmt, const char *src)
+{
+  char tmp[LONG_STRING];
+  
+  mutt_quote_filename (tmp, sizeof (tmp), src);
+  mutt_expand_fmt (dest, destlen, fmt, tmp);
+}
+
+void mutt_expand_fmt (char *dest, size_t destlen, const char *fmt, const char *src)
+{
+  const char *p;
+  char *d;
+  size_t slen;
+  int found = 0;
+
+  slen = mutt_strlen (src);
+  destlen--;
+  
+  for (p = fmt, d = dest; destlen && *p; p++)
+  {
+    if (*p == '%') 
+    {
+      switch (p[1])
+      {
+	case '%':
+	  *d++ = *p++;
+	  destlen--;
+	  break;
+	case 's':
+	  found = 1;
+	  strfcpy (d, src, destlen + 1);
+	  d       += destlen > slen ? slen : destlen;
+	  destlen -= destlen > slen ? slen : destlen;
+	  p++;
+	  break;
+	default:
+	  *d++ = *p; 
+	  destlen--;
+	  break;
+      }
+    }
+    else
+    {
+      *d++ = *p;
+      destlen--;
+    }
+  }
+  
+  *d = '\0';
+  
+  if (!found && destlen > 0)
+  {
+    safe_strcat (dest, destlen, " ");
+    safe_strcat (dest, destlen, src);
+  }
+  
+}
+
+/* return 0 on success, -1 on abort, 1 on error */
+int mutt_check_overwrite (const char *attname, const char *path,
+				char *fname, size_t flen, int *append, char **directory) 
+{
+  int rc = 0;
+  char tmp[_POSIX_PATH_MAX];
+  struct stat st;
+
+  strfcpy (fname, path, flen);
+  if (access (fname, F_OK) != 0)
+    return 0;
+  if (stat (fname, &st) != 0)
+    return -1;
+  if (S_ISDIR (st.st_mode))
+  {
+    if (directory)
+    {
+      switch (mutt_multi_choice
+	      (_("File is a directory, save under it? [(y)es, (n)o, (a)ll]"), _("yna")))
+      {
+	case 3:		/* all */
+	  mutt_str_replace (directory, fname);
+	  break;
+	case 1:		/* yes */
+	  FREE (directory);		/* __FREE_CHECKED__ */
+	  break;
+	case -1:	/* abort */
+	  FREE (directory); 		/* __FREE_CHECKED__ */
+	  return -1;
+	case  2:	/* no */
+	  FREE (directory);		/* __FREE_CHECKED__ */
+	  return 1;
+      }
+    }
+    else if ((rc = mutt_yesorno (_("File is a directory, save under it?"), M_YES)) != M_YES)
+      return (rc == M_NO) ? 1 : -1;
+
+    strfcpy (tmp, mutt_basename (NONULL (attname)), sizeof (tmp));
+    if (mutt_get_field (_("File under directory: "), tmp, sizeof (tmp),
+                                    M_FILE | M_CLEAR) != 0 || !tmp[0])
+      return (-1);
+    mutt_concat_path (fname, path, tmp, flen);
+  }
+  
+  if (*append == 0 && access (fname, F_OK) == 0)
+  {
+    switch (mutt_multi_choice
+	    (_("File exists, (o)verwrite, (a)ppend, or (c)ancel?"), _("oac")))
+    {
+      case -1: /* abort */
+        return -1;
+      case 3:  /* cancel */
+	return 1;
+
+      case 2: /* append */
+        *append = M_SAVE_APPEND;
+        break;
+      case 1: /* overwrite */
+        *append = M_SAVE_OVERWRITE;
+        break;
+    }
+  }
+  return 0;
+}
+
+void mutt_save_path (char *d, size_t dsize, ADDRESS *a)
+{
+  if (a && a->mailbox)
+  {
+    strfcpy (d, a->mailbox, dsize);
+    if (!option (OPTSAVEADDRESS))
+    {
+      char *p;
+
+      if ((p = strpbrk (d, "%@")))
+	*p = 0;
+    }
+    mutt_strlower (d);
+  }
+  else
+    *d = 0;
+}
+
+void mutt_safe_path (char *s, size_t l, ADDRESS *a)
+{
+  char *p;
+
+  mutt_save_path (s, l, a);
+  for (p = s; *p; p++)
+    if (*p == '/' || ISSPACE (*p) || !IsPrint ((unsigned char) *p))
+      *p = '_';
+}
+
+
+void mutt_FormatString (char *dest,		/* output buffer */
+			size_t destlen,		/* output buffer len */
+			size_t col,		/* starting column (nonzero when called recursively) */
+			const char *src,	/* template string */
+			format_t *callback,	/* callback for processing */
+			unsigned long data,	/* callback data */
+			format_flag flags)	/* callback flags */
+{
+  char prefix[SHORT_STRING], buf[LONG_STRING], *cp, *wptr = dest, ch;
+  char ifstring[SHORT_STRING], elsestring[SHORT_STRING];
+  size_t wlen, count, len, wid;
+  pid_t pid;
+  FILE *filter;
+  int n;
+  char *recycler;
+
+  prefix[0] = '\0';
+  destlen--; /* save room for the terminal \0 */
+  wlen = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+  col += wlen;
+
+  if ((flags & M_FORMAT_NOFILTER) == 0)
+  {
+    int off = -1;
+
+    /* Do not consider filters if no pipe at end */
+    n = mutt_strlen(src);
+    if (n > 1 && src[n-1] == '|')
+    {
+      /* Scan backwards for backslashes */
+      off = n;
+      while (off > 0 && src[off-2] == '\\')
+        off--;
+    }
+
+    /* If number of backslashes is even, the pipe is real. */
+    /* n-off is the number of backslashes. */
+    if (off > 0 && ((n-off) % 2) == 0)
+    {
+      BUFFER *srcbuf, *word, *command;
+      char    srccopy[LONG_STRING];
+#ifdef DEBUG
+      int     i = 0;
+#endif
+
+      dprint(3, (debugfile, "fmtpipe = %s\n", src));
+
+      strncpy(srccopy, src, n);
+      srccopy[n-1] = '\0';
+
+      /* prepare BUFFERs */
+      srcbuf = mutt_buffer_from (srccopy);
+      srcbuf->dptr = srcbuf->data;
+      word = mutt_buffer_new ();
+      command = mutt_buffer_new ();
+
+      /* Iterate expansions across successive arguments */
+      do {
+        char *p;
+
+        /* Extract the command name and copy to command line */
+        dprint(3, (debugfile, "fmtpipe +++: %s\n", srcbuf->dptr));
+        if (word->data)
+          *word->data = '\0';
+        mutt_extract_token(word, srcbuf, 0);
+        dprint(3, (debugfile, "fmtpipe %2d: %s\n", i++, word->data));
+        mutt_buffer_addch(command, '\'');
+        mutt_FormatString(buf, sizeof(buf), 0, word->data, callback, data,
+                          flags | M_FORMAT_NOFILTER);
+        for (p = buf; p && *p; p++)
+        {
+          if (*p == '\'')
+            /* shell quoting doesn't permit escaping a single quote within
+             * single-quoted material.  double-quoting instead will lead
+             * shell variable expansions, so break out of the single-quoted
+             * span, insert a double-quoted single quote, and resume. */
+            mutt_buffer_addstr(command, "'\"'\"'");
+          else
+            mutt_buffer_addch(command, *p);
+        }
+        mutt_buffer_addch(command, '\'');
+        mutt_buffer_addch(command, ' ');
+      } while (MoreArgs(srcbuf));
+
+      dprint(3, (debugfile, "fmtpipe > %s\n", command->data));
+
+      col -= wlen;	/* reset to passed in value */
+      wptr = dest;      /* reset write ptr */
+      wlen = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+      if ((pid = mutt_create_filter(command->data, NULL, &filter, NULL)) != -1)
+      {
+	int rc;
+
+        n = fread(dest, 1, destlen /* already decremented */, filter);
+        safe_fclose (&filter);
+	rc = mutt_wait_filter(pid);
+	if (rc != 0)
+	  dprint(1, (debugfile, "format pipe command exited code %d\n", rc));
+	if (n > 0) {
+	  dest[n] = 0;
+	  while ((n > 0) && (dest[n-1] == '\n' || dest[n-1] == '\r'))
+	    dest[--n] = '\0';
+	  dprint(3, (debugfile, "fmtpipe < %s\n", dest));
+
+	  /* If the result ends with '%', this indicates that the filter
+	   * generated %-tokens that mutt can expand.  Eliminate the '%'
+	   * marker and recycle the string through mutt_FormatString().
+	   * To literally end with "%", use "%%". */
+	  if ((n > 0) && dest[n-1] == '%')
+	  {
+	    --n;
+	    dest[n] = '\0';               /* remove '%' */
+	    if ((n > 0) && dest[n-1] != '%')
+	    {
+	      recycler = safe_strdup(dest);
+	      if (recycler)
+	      {
+		/* destlen is decremented at the start of this function
+		 * to save space for the terminal nul char.  We can add
+		 * it back for the recursive call since the expansion of
+		 * format pipes does not try to append a nul itself.
+		 */
+		mutt_FormatString(dest, destlen+1, col, recycler, callback, data, flags);
+		FREE(&recycler);
+	      }
+	    }
+	  }
+	}
+	else
+	{
+	  /* read error */
+	  dprint(1, (debugfile, "error reading from fmtpipe: %s (errno=%d)\n", strerror(errno), errno));
+	  *wptr = 0;
+	}
+      }
+      else
+      {
+        /* Filter failed; erase write buffer */
+        *wptr = '\0';
+      }
+
+      mutt_buffer_free(&command);
+      mutt_buffer_free(&srcbuf);
+      mutt_buffer_free(&word);
+      return;
+    }
+  }
+
+  while (*src && wlen < destlen)
+  {
+    if (*src == '%')
+    {
+      if (*++src == '%')
+      {
+	*wptr++ = '%';
+	wlen++;
+	col++;
+	src++;
+	continue;
+      }
+
+      if (*src == '?')
+      {
+	flags |= M_FORMAT_OPTIONAL;
+	src++;
+      }
+      else
+      {
+	flags &= ~M_FORMAT_OPTIONAL;
+
+	/* eat the format string */
+	cp = prefix;
+	count = 0;
+	while (count < sizeof (prefix) &&
+	       (isdigit ((unsigned char) *src) || *src == '.' || *src == '-' || *src == '='))
+	{
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
+      }
+
+      if (!*src)
+	break; /* bad format */
+
+      ch = *src++; /* save the character to switch on */
+
+      if (flags & M_FORMAT_OPTIONAL)
+      {
+        if (*src != '?')
+          break; /* bad format */
+        src++;
+
+        /* eat the `if' part of the string */
+        cp = ifstring;
+	count = 0;
+        while (count < sizeof (ifstring) && *src && *src != '?' && *src != '&')
+	{
+          *cp++ = *src++;
+	  count++;
+	}
+        *cp = 0;
+
+	/* eat the `else' part of the string (optional) */
+	if (*src == '&')
+	  src++; /* skip the & */
+	cp = elsestring;
+	count = 0;
+	while (count < sizeof (elsestring) && *src && *src != '?')
+	{
+	  *cp++ = *src++;
+	  count++;
+	}
+	*cp = 0;
+
+	if (!*src)
+	  break; /* bad format */
+
+        src++; /* move past the trailing `?' */
+      }
+
+      /* handle generic cases first */
+      if (ch == '>' || ch == '*')
+      {
+	/* %>X: right justify to EOL, left takes precedence
+	 * %*X: right justify to EOL, right takes precedence */
+	int soft = ch == '*';
+	int pl, pw;
+	if ((pl = mutt_charlen (src, &pw)) <= 0)
+	  pl = pw = 1;
+
+	/* see if there's room to add content, else ignore */
+	if ((col < COLS && wlen < destlen) || soft)
+	{
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    int offset = ((flags & M_FORMAT_ARROWCURSOR) && option (OPTARROWCURSOR)) ? 3 : 0;
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS-offset, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad*pw -offset, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+	break; /* skip rest of input */
+      }
+      else if (ch == '|')
+      {
+	/* pad to EOL */
+	int pl, pw, c;
+	if ((pl = mutt_charlen (src, &pw)) <= 0)
+	  pl = pw = 1;
+
+	/* see if there's room to add content, else ignore */
+	if (col < COLS && wlen < destlen)
+	{
+	  c = (COLS - col) / pw;
+	  if (c > 0 && wlen + (c * pl) > destlen)
+	    c = ((signed)(destlen - wlen)) / pl;
+	  while (c > 0)
+	  {
+	    memcpy (wptr, src, pl);
+	    wptr += pl;
+	    wlen += pl;
+	    col += pw;
+	    c--;
+	  }
+	  src += pl;
+	}
+	break; /* skip rest of input */
+      }
+      else
+      {
+	short tolower =  0;
+	short nodots  = 0;
+	
+	while (ch == '_' || ch == ':') 
+	{
+	  if (ch == '_')
+	    tolower = 1;
+	  else if (ch == ':') 
+	    nodots = 1;
+	  
+	  ch = *src++;
+	}
+	
+	/* use callback function to handle this case */
+	src = callback (buf, sizeof (buf), col, ch, src, prefix, ifstring, elsestring, data, flags);
+
+	if (tolower)
+	  mutt_strlower (buf);
+	if (nodots) 
+	{
+	  char *p = buf;
+	  for (; *p; p++)
+	    if (*p == '.')
+		*p = '_';
+	}
+	
+	if ((len = mutt_strlen (buf)) + wlen > destlen)
+	  len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+
+	memcpy (wptr, buf, len);
+	wptr += len;
+	wlen += len;
+	col += mutt_strwidth (buf);
+      }
+    }
+    else if (*src == '\\')
+    {
+      if (!*++src)
+	break;
+      switch (*src)
+      {
+	case 'n':
+	  *wptr = '\n';
+	  break;
+	case 't':
+	  *wptr = '\t';
+	  break;
+	case 'r':
+	  *wptr = '\r';
+	  break;
+	case 'f':
+	  *wptr = '\f';
+	  break;
+	case 'v':
+	  *wptr = '\v';
+	  break;
+	default:
+	  *wptr = *src;
+	  break;
+      }
+      src++;
+      wptr++;
+      wlen++;
+      col++;
+    }
+    else
+    {
+      int tmp, w;
+      /* in case of error, simply copy byte */
+      if ((tmp = mutt_charlen (src, &w)) < 0)
+	tmp = w = 1;
+      if (tmp > 0 && wlen + tmp < destlen)
+      {
+        memcpy (wptr, src, tmp);
+        wptr += tmp;
+        src += tmp;
+        wlen += tmp;
+        col += w;
+      }
+      else
+      {
+	src += destlen - wlen;
+	wlen = destlen;
+      }
+    }
+  }
+  *wptr = 0;
+
+#if 0
+  if (flags & M_FORMAT_MAKEPRINT)
+  {
+    /* Make sure that the string is printable by changing all non-printable
+       chars to dots, or spaces for non-printable whitespace */
+    for (cp = dest ; *cp ; cp++)
+      if (!IsPrint (*cp) &&
+	  !((flags & M_FORMAT_TREE) && (*cp <= M_TREE_MAX)))
+	*cp = isspace ((unsigned char) *cp) ? ' ' : '.';
+  }
+#endif
+}
+
+/* This function allows the user to specify a command to read stdout from in
+   place of a normal file.  If the last character in the string is a pipe (|),
+   then we assume it is a command to run instead of a normal file. */
+FILE *mutt_open_read (const char *path, pid_t *thepid)
+{
+  FILE *f;
+  struct stat s;
+
+  int len = mutt_strlen (path);
+
+  if (path[len - 1] == '|')
+  {
+    /* read from a pipe */
+
+    char *s = safe_strdup (path);
+
+    s[len - 1] = 0;
+    mutt_endwin (NULL);
+    *thepid = mutt_create_filter (s, NULL, &f, NULL);
+    FREE (&s);
+  }
+  else
+  {
+    if (stat (path, &s) < 0)
+      return (NULL);
+    if (S_ISDIR (s.st_mode))
+    {
+      errno = EINVAL;
+      return (NULL);
+    }
+    f = fopen (path, "r");
+    *thepid = -1;
+  }
+  return (f);
+}
+
+/* returns 0 if OK to proceed, -1 to abort, 1 to retry */
+int mutt_save_confirm (const char *s, struct stat *st)
+{
+  char tmp[_POSIX_PATH_MAX];
+  int ret = 0;
+  int rc;
+  int magic = 0;
+
+  magic = mx_get_magic (s);
+
+#ifdef USE_POP
+  if (magic == M_POP)
+  {
+    mutt_error _("Can't save message to POP mailbox.");
+    return 1;
+  }
+#endif
+
+  if (magic > 0 && !mx_access (s, W_OK))
+  {
+    if (option (OPTCONFIRMAPPEND))
+    {
+      snprintf (tmp, sizeof (tmp), _("Append messages to %s?"), s);
+      if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+	ret = 1;
+      else if (rc == -1)
+	ret = -1;
+    }
+  }
+
+  if (stat (s, st) != -1)
+  {
+    if (magic == -1)
+    {
+      mutt_error (_("%s is not a mailbox!"), s);
+      return 1;
+    }
+  }
+  else if (magic != M_IMAP)
+  {
+    st->st_mtime = 0;
+    st->st_atime = 0;
+
+    if (errno == ENOENT)
+    {
+      if (option (OPTCONFIRMCREATE))
+      {
+	snprintf (tmp, sizeof (tmp), _("Create %s?"), s);
+	if ((rc = mutt_yesorno (tmp, M_YES)) == M_NO)
+	  ret = 1;
+	else if (rc == -1)
+	  ret = -1;
+      }
+    }
+    else
+    {
+      mutt_perror (s);
+      return 1;
+    }
+  }
+
+  CLEARLINE (LINES-1);
+  return (ret);
+}
+
+void state_prefix_putc (char c, STATE *s)
+{
+  if (s->flags & M_PENDINGPREFIX)
+  {
+    state_reset_prefix (s);
+    if (s->prefix)
+      state_puts (s->prefix, s);
+  }
+
+  state_putc (c, s);
+
+  if (c == '\n')
+    state_set_prefix (s);
+}
+
+int state_printf (STATE *s, const char *fmt, ...)
+{
+  int rv;
+  va_list ap;
+
+  va_start (ap, fmt);
+  rv = vfprintf (s->fpout, fmt, ap);
+  va_end (ap);
+  
+  return rv;
+}
+
+void state_mark_attach (STATE *s)
+{
+  if ((s->flags & M_DISPLAY) && !mutt_strcmp (Pager, "builtin"))
+    state_puts (AttachmentMarker, s);
+}
+
+void state_attach_puts (const char *t, STATE *s)
+{
+  if (*t != '\n') state_mark_attach (s);
+  while (*t)
+  {
+    state_putc (*t, s);
+    if (*t++ == '\n' && *t)
+      if (*t != '\n') state_mark_attach (s);
+  }
+}
+
+int state_putwc (wchar_t wc, STATE *s)
+{
+  char mb[MB_LEN_MAX] = "";
+  int rc;
+
+  if ((rc = wcrtomb (mb, wc, NULL)) < 0)
+    return rc;
+  if (fputs (mb, s->fpout) == EOF)
+    return -1;
+  return 0;
+}
+
+int state_putws (const wchar_t *ws, STATE *s)
+{
+  const wchar_t *p = ws;
+
+  while (p && *p != L'\0')
+  {
+    if (state_putwc (*p, s) < 0)
+      return -1;
+    p++;
+  }
+  return 0;
+}
+
+void mutt_display_sanitize (char *s)
+{
+  for (; *s; s++)
+  {
+    if (!IsPrint (*s))
+      *s = '?';
+  }
+}
+      
+void mutt_sleep (short s)
+{
+  if (SleepTime > s)
+    sleep (SleepTime);
+  else if (s)
+    sleep(s);
+}
+
+/* creates and initializes a BUFFER */
+BUFFER *mutt_buffer_new(void) {
+  BUFFER *b;
+
+  b = safe_malloc(sizeof(BUFFER));
+
+  mutt_buffer_init(b);
+
+  return b;
+}
+
+/* initialize a new BUFFER */
+BUFFER *mutt_buffer_init (BUFFER *b) {
+  memset(b, 0, sizeof(BUFFER));
+  return b;
+}
+
+/*
+ * Creates and initializes a BUFFER*. If passed an existing BUFFER*,
+ * just initializes. Frees anything already in the buffer. Copies in
+ * the seed string.
+ *
+ * Disregards the 'destroy' flag, which seems reserved for caller.
+ * This is bad, but there's no apparent protocol for it.
+ */
+BUFFER *mutt_buffer_from (char *seed) {
+  BUFFER *b;
+
+  if (!seed)
+    return NULL;
+
+  b = mutt_buffer_new ();
+  b->data = safe_strdup(seed);
+  b->dsize = mutt_strlen(seed);
+  b->dptr = (char *) b->data + b->dsize;
+  return b;
+}
+
+int mutt_buffer_printf (BUFFER* buf, const char* fmt, ...)
+{
+  va_list ap, ap_retry;
+  int len, blen, doff;
+  
+  va_start (ap, fmt);
+  va_copy (ap_retry, ap);
+
+  if (!buf->dptr)
+    buf->dptr = buf->data;
+
+  doff = buf->dptr - buf->data;
+  blen = buf->dsize - doff;
+  /* solaris 9 vsnprintf barfs when blen is 0 */
+  if (!blen)
+  {
+    blen = 128;
+    buf->dsize += blen;
+    safe_realloc (&buf->data, buf->dsize);
+    buf->dptr = buf->data + doff;
+  }
+  if ((len = vsnprintf (buf->dptr, blen, fmt, ap)) >= blen)
+  {
+    blen = ++len - blen;
+    if (blen < 128)
+      blen = 128;
+    buf->dsize += blen;
+    safe_realloc (&buf->data, buf->dsize);
+    buf->dptr = buf->data + doff;
+    len = vsnprintf (buf->dptr, len, fmt, ap_retry);
+  }
+  if (len > 0)
+    buf->dptr += len;
+
+  va_end (ap);
+  va_end (ap_retry);
+
+  return len;
+}
+
+void mutt_buffer_addstr (BUFFER* buf, const char* s)
+{
+  mutt_buffer_add (buf, s, mutt_strlen (s));
+}
+
+void mutt_buffer_addch (BUFFER* buf, char c)
+{
+  mutt_buffer_add (buf, &c, 1);
+}
+
+void mutt_buffer_free (BUFFER **p)
+{
+  if (!p || !*p) 
+    return;
+
+   FREE(&(*p)->data);
+   /* dptr is just an offset to data and shouldn't be freed */
+   FREE(p);		/* __FREE_CHECKED__ */
+}
+
+/* dynamically grows a BUFFER to accommodate s, in increments of 128 bytes.
+ * Always one byte bigger than necessary for the null terminator, and
+ * the buffer is always null-terminated */
+void mutt_buffer_add (BUFFER* buf, const char* s, size_t len)
+{
+  size_t offset;
+
+  if (buf->dptr + len + 1 > buf->data + buf->dsize)
+  {
+    offset = buf->dptr - buf->data;
+    buf->dsize += len < 128 ? 128 : len + 1;
+    /* suppress compiler aliasing warning */
+    safe_realloc ((void**) (void*) &buf->data, buf->dsize);
+    buf->dptr = buf->data + offset;
+  }
+  memcpy (buf->dptr, s, len);
+  buf->dptr += len;
+  *(buf->dptr) = '\0';
+}
+
+/* Decrease a file's modification time by 1 second */
+
+time_t mutt_decrease_mtime (const char *f, struct stat *st)
+{
+  struct utimbuf utim;
+  struct stat _st;
+  time_t mtime;
+  
+  if (!st)
+  {
+    if (stat (f, &_st) == -1)
+      return -1;
+    st = &_st;
+  }
+
+  if ((mtime = st->st_mtime) == time (NULL))
+  {
+    mtime -= 1;
+    utim.actime = mtime;
+    utim.modtime = mtime;
+    utime (f, &utim);
+  }
+  
+  return mtime;
+}
+
+/* sets mtime of 'to' to mtime of 'from' */
+void mutt_set_mtime (const char* from, const char* to)
+{
+  struct utimbuf utim;
+  struct stat st;
+
+  if (stat (from, &st) != -1)
+  {
+    utim.actime = st.st_mtime;
+    utim.modtime = st.st_mtime;
+    utime (to, &utim);
+  }
+}
+
+const char *mutt_make_version (void)
+{
+  static char vstring[STRING];
+  snprintf (vstring, sizeof (vstring), "Mutt %s (%s)",
+	    MUTT_VERSION, ReleaseDate);
+  return vstring;
+}
+
+REGEXP *mutt_compile_regexp (const char *s, int flags)
+{
+  REGEXP *pp = safe_calloc (sizeof (REGEXP), 1);
+  pp->pattern = safe_strdup (s);
+  pp->rx = safe_calloc (sizeof (regex_t), 1);
+  if (REGCOMP (pp->rx, NONULL(s), flags) != 0)
+    mutt_free_regexp (&pp);
+
+  return pp;
+}
+
+void mutt_free_regexp (REGEXP **pp)
+{
+  FREE (&(*pp)->pattern);
+  regfree ((*pp)->rx);
+  FREE (&(*pp)->rx);
+  FREE (pp);		/* __FREE_CHECKED__ */
+}
+
+void mutt_free_rx_list (RX_LIST **list)
+{
+  RX_LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    mutt_free_regexp (&p->rx);
+    FREE (&p);
+  }
+}
+
+void mutt_free_spam_list (SPAM_LIST **list)
+{
+  SPAM_LIST *p;
+  
+  if (!list) return;
+  while (*list)
+  {
+    p = *list;
+    *list = (*list)->next;
+    mutt_free_regexp (&p->rx);
+    FREE (&p->template);
+    FREE (&p);
+  }
+}
+
+int mutt_match_rx_list (const char *s, RX_LIST *l)
+{
+  if (!s)  return 0;
+  
+  for (; l; l = l->next)
+  {
+    if (regexec (l->rx->rx, s, (size_t) 0, (regmatch_t *) 0, (int) 0) == 0)
+    {
+      dprint (5, (debugfile, "mutt_match_rx_list: %s matches %s\n", s, l->rx->pattern));
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+/* Match a string against the patterns defined by the 'spam' command and output
+ * the expanded format into `text` when there is a match.  If textsize<=0, the
+ * match is performed but the format is not expanded and no assumptions are made
+ * about the value of `text` so it may be NULL.
+ *
+ * Returns 1 if the argument `s` matches a pattern in the spam list, otherwise
+ * 0. */
+int mutt_match_spam_list (const char *s, SPAM_LIST *l, char *text, int textsize)
+{
+  static regmatch_t *pmatch = NULL;
+  static int nmatch = 0;
+  int tlen = 0;
+  char *p;
+
+  if (!s) return 0;
+
+  for (; l; l = l->next)
+  {
+    /* If this pattern needs more matches, expand pmatch. */
+    if (l->nmatch > nmatch)
+    {
+      safe_realloc (&pmatch, l->nmatch * sizeof(regmatch_t));
+      nmatch = l->nmatch;
+    }
+
+    /* Does this pattern match? */
+    if (regexec (l->rx->rx, s, (size_t) l->nmatch, (regmatch_t *) pmatch, (int) 0) == 0)
+    {
+      dprint (5, (debugfile, "mutt_match_spam_list: %s matches %s\n", s, l->rx->pattern));
+      dprint (5, (debugfile, "mutt_match_spam_list: %d subs\n", (int)l->rx->rx->re_nsub));
+
+      /* Copy template into text, with substitutions. */
+      for (p = l->template; *p && tlen < textsize - 1;)
+      {
+	/* backreference to pattern match substring, eg. %1, %2, etc) */
+	if (*p == '%')
+	{
+	  char *e; /* used as pointer to end of integer backreference in strtol() call */
+	  int n;
+
+	  ++p; /* skip over % char */
+	  n = strtol(p, &e, 10);
+	  /* Ensure that the integer conversion succeeded (e!=p) and bounds check.  The upper bound check
+	   * should not strictly be necessary since add_to_spam_list() finds the largest value, and
+	   * the static array above is always large enough based on that value. */
+	  if (e != p && n >= 0 && n <= l->nmatch && pmatch[n].rm_so != -1) {
+	    /* copy as much of the substring match as will fit in the output buffer, saving space for
+	     * the terminating nul char */
+	    int idx;
+	    for (idx = pmatch[n].rm_so; (idx < pmatch[n].rm_eo) && (tlen < textsize - 1); ++idx)
+	      text[tlen++] = s[idx];
+	  }
+	  p = e; /* skip over the parsed integer */
+	}
+	else
+	{
+	  text[tlen++] = *p++;
+	}
+      }
+      /* tlen should always be less than textsize except when textsize<=0
+       * because the bounds checks in the above code leave room for the
+       * terminal nul char.   This should avoid returning an unterminated
+       * string to the caller.  When textsize<=0 we make no assumption about
+       * the validity of the text pointer. */
+      if (tlen < textsize) {
+	text[tlen] = '\0';
+	dprint (5, (debugfile, "mutt_match_spam_list: \"%s\"\n", text));
+      }
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+void mutt_encode_path (char *dest, size_t dlen, const char *src)
+{
+  char *p = safe_strdup (src);
+  int rc = mutt_convert_string (&p, Charset, "utf-8", 0);
+  /* `src' may be NULL, such as when called from the pop3 driver. */
+  strfcpy (dest, (rc == 0) ? NONULL(p) : NONULL(src), dlen);
+  FREE (&p);
+}
diff -uNp -r mutt.b/mx.c mutt.a/mx.c
--- mutt.b/mx.c	2015-09-23 10:26:44.000000000 +0200
+++ mutt.a/mx.c	2015-09-23 10:28:45.000000000 +0200
@@ -776,6 +776,53 @@ static int sync_mailbox (CONTEXT *ctx, i
   return rc;
 }
 
+/* move deleted mails to the trash folder */
+static int trash_append (CONTEXT *ctx)
+{
+    CONTEXT *ctx_trash;
+    int i = 0;
+    struct stat st, stc;
+
+    if (!TrashPath || !ctx->deleted ||
+       (ctx->magic == M_MAILDIR && option (OPTMAILDIRTRASH)))
+      return 0;
+
+    for (;i < ctx->msgcount && (!ctx->hdrs[i]->deleted ||
+                               ctx->hdrs[i]->appended); i++);
+    if (i == ctx->msgcount)
+      return 0; /* nothing to be done */
+
+    if (mutt_save_confirm (TrashPath, &st) != 0)
+    {
+      mutt_error _("message(s) not deleted");
+      return -1;
+    }
+
+    if (lstat (ctx->path, &stc) == 0 && stc.st_ino == st.st_ino
+       && stc.st_dev == st.st_dev && stc.st_rdev == st.st_rdev)
+      return 0;  /* we are in the trash folder: simple sync */
+
+    if ((ctx_trash = mx_open_mailbox (TrashPath, M_APPEND, NULL)) != NULL)
+    {
+      for (i = 0 ; i < ctx->msgcount ; i++)
+       if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->appended
+           && mutt_append_message (ctx_trash, ctx, ctx->hdrs[i], 0, 0) == -1)
+         {
+           mx_close_mailbox (ctx_trash, NULL);
+           return -1;
+         }
+
+      mx_close_mailbox (ctx_trash, NULL);
+    }
+    else
+    {
+      mutt_error _("Can't open trash folder");
+      return -1;
+    }
+
+    return 0;
+}
+
 /* save changes and close mailbox */
 int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
 {
@@ -912,6 +959,7 @@ int mx_close_mailbox (CONTEXT *ctx, int 
 	  if (mutt_append_message (&f, ctx, ctx->hdrs[i], 0, CH_UPDATE_LEN) == 0)
 	  {
 	    mutt_set_flag (ctx, ctx->hdrs[i], M_DELETE, 1);
+            mutt_set_flag (ctx, ctx->hdrs[i], M_APPENDED, 1);
 	  }
 	  else
 	  {
@@ -936,6 +984,14 @@ int mx_close_mailbox (CONTEXT *ctx, int 
     return 0;
   }
   
+  /* copy mails to the trash before expunging */
+  if (purge && ctx->deleted)
+    if (trash_append (ctx) != 0)
+    {
+      ctx->closing = 0;
+      return -1;
+    }
+
 #ifdef USE_IMAP
   /* allow IMAP to preserve the deleted flag across sessions */
   if (ctx->magic == M_IMAP)
@@ -1133,6 +1189,12 @@ int mx_sync_mailbox (CONTEXT *ctx, int *
   msgcount = ctx->msgcount;
   deleted = ctx->deleted;
 
+  if (purge && ctx->deleted)
+  {
+    if (trash_append (ctx) == -1)
+      return -1;
+  } 
+
 #ifdef USE_IMAP
   if (ctx->magic == M_IMAP)
     rc = imap_sync_mailbox (ctx, purge, index_hint);
diff -uNp -r mutt.b/postpone.c mutt.a/postpone.c
--- mutt.b/postpone.c	2015-09-23 10:25:53.000000000 +0200
+++ mutt.a/postpone.c	2015-09-23 10:28:45.000000000 +0200
@@ -277,6 +277,9 @@ int mutt_get_postponed (CONTEXT *ctx, HE
   /* finished with this message, so delete it. */
   mutt_set_flag (PostContext, h, M_DELETE, 1);
 
+  /* and consider it saved, so that it won't be moved to the trash folder */
+  mutt_set_flag (PostContext, h, M_APPENDED, 1);
+
   /* update the count for the status display */
   PostCount = PostContext->msgcount - PostContext->deleted;
 
